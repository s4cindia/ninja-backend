 1. Add addAccessModes method to epub-modifier.service.ts

  Add this new method (after addAccessibilityMetadata):

  async addAccessModes(
    zip: JSZip,
    modes: { textual?: boolean; visual?: boolean; auditory?: boolean } = { textual: true }
  ): Promise<ModificationResult[]> {
    const results: ModificationResult[] = [];
    const opf = await this.getOPF(zip);
    if (!opf) {
      return [{
        success: false,
        filePath: 'content.opf',
        modificationType: 'add_access_modes',
        description: 'Failed to locate OPF file',
      }];
    }

    let modified = opf.content;
    const metadataToAdd: string[] = [];

    // Helper to check if a specific accessMode value already exists
    const hasAccessMode = (value: string): boolean => {
      const escapedVal = value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const pattern = new RegExp(
        `<meta[^>]*property\\s*=\\s*["']schema:accessMode["'][^>]*>\\s*${escapedVal}\\s*</meta>`,
        'i'
      );
      return pattern.test(modified);
    };

    const hasAccessModeSufficient = (value: string): boolean => {
      const escapedVal = value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const pattern = new RegExp(
        `<meta[^>]*property\\s*=\\s*["']schema:accessModeSufficient["'][^>]*>\\s*${escapedVal}\\s*</meta>`,
        'i'
      );
      return pattern.test(modified);
    };

    // Add accessMode values
    if (modes.textual && !hasAccessMode('textual')) {
      metadataToAdd.push('<meta property="schema:accessMode">textual</meta>');
    }
    if (modes.visual && !hasAccessMode('visual')) {
      metadataToAdd.push('<meta property="schema:accessMode">visual</meta>');
    }
    if (modes.auditory && !hasAccessMode('auditory')) {
      metadataToAdd.push('<meta property="schema:accessMode">auditory</meta>');
    }

    // Add accessModeSufficient (typically textual for text-based EPUBs)
    if (modes.textual && !hasAccessModeSufficient('textual')) {
      metadataToAdd.push('<meta property="schema:accessModeSufficient">textual</meta>');
    }

    if (metadataToAdd.length === 0) {
      return [{
        success: true,
        filePath: opf.path,
        modificationType: 'add_access_modes',
        description: 'Access modes already present',
      }];
    }

    const insertContent = '\n    ' + metadataToAdd.join('\n    ');
    modified = modified.replace('</metadata>', insertContent + '\n</metadata>');
    await this.updateOPF(zip, opf.path, modified);

    results.push({
      success: true,
      filePath: opf.path,
      modificationType: 'add_access_modes',
      description: `Added ${metadataToAdd.length} access mode elements`,
      after: metadataToAdd.join('\n'),
    });

    return results;
  }

  2. Update addAccessibilityMetadata to remove accessMode logic

  Remove these lines from addAccessibilityMetadata (around lines 358-367):

  // REMOVE these lines:
  // Add accessMode only if not present
  if (!hasMetaValue('schema:accessMode')) {
    metadataToAdd.push('<meta property="schema:accessMode">textual</meta>');
  }
  // Add accessModeSufficient only if not present
  if (!hasMetaValue('schema:accessModeSufficient')) {
    metadataToAdd.push('<meta property="schema:accessModeSufficient">textual</meta>');
  }

  3. Update auto-remediation.service.ts

  'EPUB-META-004': async (zip) => {
    return epubModifier.addAccessModes(zip, { textual: true });
  },

  This separates the concerns so each fix case handles its specific metadata type without duplicates.
