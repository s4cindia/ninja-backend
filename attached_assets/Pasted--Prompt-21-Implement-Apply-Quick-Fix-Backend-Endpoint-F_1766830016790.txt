 Prompt 21: Implement Apply Quick Fix Backend Endpoint

  For ninja-backend:

  Create the endpoint

  File: src/routes/epub.routes.ts (add route):

  // Apply quick fix to EPUB
  router.post('/job/:jobId/apply-fix', asyncHandler(epubController.applyQuickFix));

  File: src/controllers/epub.controller.ts (add controller method):

  async applyQuickFix(req: Request, res: Response) {
    const { jobId } = req.params;
    const { issueId, changes } = req.body;

    logger.info(`Applying quick fix for job ${jobId}, issue ${issueId}`);
    logger.info(`Changes: ${JSON.stringify(changes, null, 2)}`);

    try {
      // Get the EPUB file path
      const job = await getJobById(jobId);
      if (!job) {
        return res.status(404).json({ success: false, error: 'Job not found' });
      }

      // Apply the changes to the EPUB
      const result = await epubService.applyQuickFix(jobId, changes);

      // Update task status
      await updateTaskStatus(jobId, issueId, 'completed');

      res.json({
        success: true,
        data: {
          success: true,
          modifiedFiles: result.modifiedFiles,
        },
      });
    } catch (error) {
      logger.error(`Failed to apply quick fix: ${error}`);
      res.status(500).json({ success: false, error: 'Failed to apply fix' });
    }
  }

  File: src/services/epub/epub.service.ts (add service method):

  import JSZip from 'jszip';
  import fs from 'fs/promises';
  import path from 'path';

  interface FileChange {
    type: 'insert' | 'replace' | 'delete';
    filePath: string;
    content?: string;
    oldContent?: string;
    lineNumber?: number;
    description?: string;
  }

  async applyQuickFix(jobId: string, changes: FileChange[]): Promise<{ modifiedFiles: string[] }> {
    const epubPath = await this.getEpubPath(jobId);
    const modifiedFiles: string[] = [];

    // Read the EPUB (it's a zip file)
    const epubBuffer = await fs.readFile(epubPath);
    const zip = await JSZip.loadAsync(epubBuffer);

    for (const change of changes) {
      const filePath = change.filePath;
      const file = zip.file(filePath) || zip.file(`EPUB/${filePath}`) || zip.file(`OEBPS/${filePath}`);

      if (!file && change.type !== 'insert') {
        logger.warn(`File not found in EPUB: ${filePath}`);
        continue;
      }

      let content = file ? await file.async('string') : '';

      switch (change.type) {
        case 'insert':
          // Insert content (typically in OPF metadata section)
          if (filePath.endsWith('.opf')) {
            // Insert before </metadata>
            content = content.replace('</metadata>', `${change.content}\n</metadata>`);
          } else {
            content += '\n' + change.content;
          }
          break;

        case 'replace':
          if (change.oldContent) {
            content = content.replace(change.oldContent, change.content || '');
          }
          break;

        case 'delete':
          if (change.oldContent) {
            content = content.replace(change.oldContent, '');
          }
          break;
      }

      // Update the file in the zip
      const actualPath = file ? file.name : (filePath.startsWith('EPUB/') ? filePath : `EPUB/${filePath}`);
      zip.file(actualPath, content);
      modifiedFiles.push(actualPath);

      logger.info(`Modified file: ${actualPath}`);
    }

    // Write the modified EPUB back
    const modifiedBuffer = await zip.generateAsync({ type: 'nodebuffer' });
    await fs.writeFile(epubPath, modifiedBuffer);

    logger.info(`Quick fix applied to ${modifiedFiles.length} files in ${epubPath}`);

    return { modifiedFiles };
  }
