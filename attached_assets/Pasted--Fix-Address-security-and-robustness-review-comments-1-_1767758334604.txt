 Fix: Address security and robustness review comments

  1. File: src/controllers/feedback-attachment.controller.ts

  Fix CRLF injection in filename sanitization (around line 81):

  const safeFilename = attachment.originalName
    .replace(/[\r\n]/g, '')           // Remove CRLF to prevent header injection
    .replace(/[^\w\s.-]/g, '_');      // Replace other special chars (includes quotes)

  ---
  2. File: src/services/feedback/attachment.service.ts

  Remove overly permissive MIME type (lines 9-20):

  const ALLOWED_MIME_TYPES = [
    'image/png',
    'image/jpeg',
    'image/gif',
    'image/webp',
    'application/pdf',
    'application/epub+zip',
    // REMOVED: 'application/octet-stream' - too permissive
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'text/markdown',
    'text/plain',
  ];

  Fix ephemeral storage path (around line 23):

  // Use persistent storage path - /tmp is ephemeral in containers
  const LOCAL_STORAGE_PATH = process.env.LOCAL_STORAGE_PATH || './data/feedback-attachments';

  Restrict canAccessFeedback to owner and admins only (lines 57-76):

  private async canAccessFeedback(feedbackId: string, userId?: string): Promise<boolean> {
    const feedback = await this.prisma.feedback.findUnique({
      where: { id: feedbackId },
      select: { userId: true, tenantId: true },
    });

    if (!feedback) return false;

    // Feedback owner can always access
    if (feedback.userId === userId) return true;

    // Admins in the same tenant can access
    if (userId) {
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
        select: { tenantId: true, role: true },
      });
      // Only ADMIN role can access other users' feedback
      if (user?.role === 'ADMIN' && user.tenantId === feedback.tenantId) {
        return true;
      }
    }

    return false;
  }

  Improve S3 fallback error detection (lines 147-159):

  } catch (s3Error) {
    // Check for configuration/credential errors to determine if fallback is appropriate
    const isConfigError =
      s3Error instanceof Error && (
        s3Error.name === 'CredentialsProviderError' ||
        s3Error.name === 'InvalidAccessKeyId' ||
        s3Error.name === 'SignatureDoesNotMatch' ||
        s3Error.message.includes('credentials') ||
        s3Error.message.includes('Could not load') ||
        s3Error.message.includes('config') ||
        s3Error.message.includes('region')
      );

    if (isConfigError) {
      logger.warn(`S3 not configured, falling back to local storage: ${(s3Error as Error).name}`);
      const localPath = path.join(LOCAL_STORAGE_PATH, filename);
      await fs.mkdir(path.dirname(localPath), { recursive: true });
      await fs.writeFile(localPath, file.buffer);
      logger.info(`Local storage upload successful: ${localPath}`);
    } else {
      // Actual S3 error (network, permissions, etc.) - don't silently fallback
      logger.error(`S3 upload failed: ${(s3Error as Error).message}`);
      throw new Error(`Failed to upload file to storage: ${(s3Error as Error).message}`);
    }
  }
