Fix: Address CodeRabbit security and robustness review comments

  1. File: prisma/schema.prisma

  The filename field already stores the full S3 key path (e.g., feedback-attachments/{feedbackId}/{uuid}.ext). Add a comment to clarify:

  model FeedbackAttachment {
    id           String   @id @default(uuid())
    feedbackId   String
    feedback     Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
    filename     String   // Full storage path (S3 key or local path)
    originalName String   // Original filename from user
    mimeType     String
    size         Int
    uploadedById String?
    uploadedBy   User?    @relation("AttachmentUploader", fields: [uploadedById], references: [id], onDelete: SetNull)
    createdAt    DateTime @default(now())

    @@index([feedbackId])
  }

  ---
  2. File: src/services/feedback/attachment.service.ts

  Add authorization helper, sanitization, and cleanup logic:

  import { PrismaClient } from '@prisma/client';
  import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
  import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
  import { v4 as uuid } from 'uuid';
  import * as fs from 'fs/promises';
  import * as path from 'path';
  import { logger } from '../../utils/logger';

  const ALLOWED_MIME_TYPES = [
    'image/png',
    'image/jpeg',
    'image/gif',
    'image/webp',
    'application/pdf',
    'application/epub+zip',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'text/markdown',
    'text/plain',
  ];

  const ALLOWED_EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'pdf', 'epub', 'docx', 'md', 'txt'];
  const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
  const LOCAL_STORAGE_PATH = process.env.LOCAL_STORAGE_PATH || './uploads';

  // Sanitize filename to prevent path traversal and header injection
  function sanitizeFilename(filename: string): string {
    // Remove path separators and null bytes
    const sanitized = filename
      .replace(/[/\\]/g, '_')
      .replace(/\0/g, '')
      .replace(/[^\w\s.-]/g, '_'); // Keep only word chars, spaces, dots, hyphens
    return sanitized || 'unnamed';
  }

  // Get safe extension from filename
  function getSafeExtension(filename: string): string {
    const parts = filename.split('.');
    if (parts.length < 2) return 'bin';
    const ext = parts.pop()?.toLowerCase() || 'bin';
    return ALLOWED_EXTENSIONS.includes(ext) ? ext : 'bin';
  }

  export class FeedbackAttachmentService {
    constructor(
      private prisma: PrismaClient,
      private s3: S3Client,
      private bucketName: string
    ) {}

    // Authorization: Check if user can access feedback
    private async canAccessFeedback(feedbackId: string, userId?: string): Promise<boolean> {
      const feedback = await this.prisma.feedback.findUnique({
        where: { id: feedbackId },
        select: { userId: true, tenantId: true },
      });

      if (!feedback) return false;

      // User can access if they created the feedback
      if (feedback.userId === userId) return true;

      // Or if user is in the same tenant (for admin review)
      if (userId) {
        const user = await this.prisma.user.findUnique({
          where: { id: userId },
          select: { tenantId: true, role: true },
        });
        if (user?.tenantId === feedback.tenantId) return true;
      }

      return false;
    }

    // Authorization: Check if user can delete attachment
    private async canDeleteAttachment(attachmentId: string, userId: string): Promise<{ allowed: boolean; attachment?: any }> {
      const attachment = await this.prisma.feedbackAttachment.findUnique({
        where: { id: attachmentId },
        include: { feedback: { select: { userId: true, tenantId: true } } },
      });

      if (!attachment) return { allowed: false };

      // Owner of attachment can delete
      if (attachment.uploadedById === userId) return { allowed: true, attachment };

      // Owner of feedback can delete any attachment
      if (attachment.feedback.userId === userId) return { allowed: true, attachment };

      // Admin in same tenant can delete
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
        select: { tenantId: true, role: true },
      });
      if (user?.role === 'ADMIN' && user.tenantId === attachment.feedback.tenantId) {
        return { allowed: true, attachment };
      }

      return { allowed: false };
    }

    // Delete file from storage (S3 or local)
    private async deleteFromStorage(filename: string): Promise<void> {
      try {
        await this.s3.send(new DeleteObjectCommand({
          Bucket: this.bucketName,
          Key: filename,
        }));
        logger.info(`Deleted from S3: ${filename}`);
      } catch (s3Error) {
        // Try local storage
        const localPath = path.join(LOCAL_STORAGE_PATH, filename);
        try {
          await fs.unlink(localPath);
          logger.info(`Deleted from local storage: ${localPath}`);
        } catch (localError) {
          logger.warn(`Could not delete file from storage: ${filename}`);
        }
      }
    }

    async upload(
      feedbackId: string,
      file: Express.Multer.File,
      userId?: string
    ) {
      // Authorization check
      const canAccess = await this.canAccessFeedback(feedbackId, userId);
      if (!canAccess) {
        throw new Error('Not authorized to add attachments to this feedback');
      }

      // Validate file type
      if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {
        throw new Error(`File type not allowed: ${file.mimetype}`);
      }

      // Validate file size
      if (file.size > MAX_FILE_SIZE) {
        throw new Error('File too large. Maximum size is 10MB');
      }

      // Safe extension extraction
      const ext = getSafeExtension(file.originalname);
      const filename = `feedback-attachments/${feedbackId}/${uuid()}.${ext}`;
      const sanitizedOriginalName = sanitizeFilename(file.originalname);

      // Upload to storage
      let uploadedToS3 = false;
      try {
        await this.s3.send(new PutObjectCommand({
          Bucket: this.bucketName,
          Key: filename,
          Body: file.buffer,
          ContentType: file.mimetype,
        }));
        uploadedToS3 = true;
        logger.info(`S3 upload successful: ${filename}`);
      } catch (s3Error) {
        const errorMessage = (s3Error as Error).message;
        // Check for credential/config errors to fallback to local
        if (s3Error instanceof Error &&
            (errorMessage.includes('credentials') ||
             errorMessage.includes('Could not load') ||
             errorMessage.includes('config'))) {
          logger.warn(`S3 not available, falling back to local storage: ${errorMessage}`);
          const localPath = path.join(LOCAL_STORAGE_PATH, filename);
          await fs.mkdir(path.dirname(localPath), { recursive: true });
          await fs.writeFile(localPath, file.buffer);
          logger.info(`Local storage upload successful: ${localPath}`);
        } else {
          logger.error(`S3 upload failed: ${errorMessage}`);
          throw new Error(`Failed to upload file to storage: ${errorMessage}`);
        }
      }

      // Create database record with cleanup on failure
      try {
        const attachment = await this.prisma.feedbackAttachment.create({
          data: {
            feedbackId,
            filename,
            originalName: sanitizedOriginalName,
            mimeType: file.mimetype,
            size: file.size,
            uploadedById: userId,
          },
          include: {
            uploadedBy: {
              select: { id: true, email: true, firstName: true, lastName: true },
            },
          },
        });
        return attachment;
      } catch (dbError) {
        // Cleanup uploaded file if database insert fails
        logger.error(`Database insert failed, cleaning up uploaded file: ${filename}`);
        await this.deleteFromStorage(filename);
        throw dbError;
      }
    }

    async list(feedbackId: string, userId?: string) {
      // Authorization check
      const canAccess = await this.canAccessFeedback(feedbackId, userId);
      if (!canAccess) {
        throw new Error('Not authorized to view attachments for this feedback');
      }

      return this.prisma.feedbackAttachment.findMany({
        where: { feedbackId },
        include: {
          uploadedBy: {
            select: { id: true, email: true, firstName: true, lastName: true },
          },
        },
        orderBy: { createdAt: 'desc' },
      });
    }

    async getDownloadUrl(attachmentId: string, userId?: string) {
      const attachment = await this.prisma.feedbackAttachment.findUnique({
        where: { id: attachmentId },
        include: { feedback: { select: { userId: true, tenantId: true } } },
      });

      if (!attachment) {
        throw new Error('Attachment not found');
      }

      // Authorization check
      const canAccess = await this.canAccessFeedback(attachment.feedbackId, userId);
      if (!canAccess) {
        throw new Error('Not authorized to download this attachment');
      }

      // Sanitize filename for Content-Disposition header
      const safeFilename = sanitizeFilename(attachment.originalName)
        .replace(/"/g, '\\"'); // Escape quotes

      try {
        const command = new GetObjectCommand({
          Bucket: this.bucketName,
          Key: attachment.filename,
          ResponseContentDisposition: `attachment; filename="${safeFilename}"`,
        });
        const url = await getSignedUrl(this.s3, command, { expiresIn: 3600 });
        return { url, attachment };
      } catch (s3Error) {
        // Check local storage
        const localPath = path.join(LOCAL_STORAGE_PATH, attachment.filename);
        try {
          await fs.access(localPath);
          return {
            url: `/api/v1/feedback/attachments/${attachmentId}/file`,
            attachment,
            isLocal: true
          };
        } catch {
          throw new Error('File not found in storage');
        }
      }
    }

    async getLocalFile(attachmentId: string, userId?: string) {
      const attachment = await this.prisma.feedbackAttachment.findUnique({
        where: { id: attachmentId },
      });

      if (!attachment) {
        throw new Error('Attachment not found');
      }

      // Authorization check
      const canAccess = await this.canAccessFeedback(attachment.feedbackId, userId);
      if (!canAccess) {
        throw new Error('Not authorized to download this attachment');
      }

      const localPath = path.join(LOCAL_STORAGE_PATH, attachment.filename);
      const fileBuffer = await fs.readFile(localPath);
      return { buffer: fileBuffer, attachment };
    }

    async delete(attachmentId: string, userId: string) {
      const { allowed, attachment } = await this.canDeleteAttachment(attachmentId, userId);

      if (!allowed || !attachment) {
        throw new Error('Not authorized to delete this attachment');
      }

      // Delete from storage
      await this.deleteFromStorage(attachment.filename);

      // Delete from database
      await this.prisma.feedbackAttachment.delete({
        where: { id: attachmentId },
      });

      return { success: true };
    }
  }

  ---
  3. File: src/controllers/feedback-attachment.controller.ts

  Update controller to pass userId for authorization:

  import { Request, Response, NextFunction } from 'express';
  import { FeedbackAttachmentService } from '../services/feedback/attachment.service';
  import { logger } from '../utils/logger';

  type MulterFile = Express.Multer.File;

  export class FeedbackAttachmentController {
    constructor(private service: FeedbackAttachmentService) {}

    upload = async (req: Request, res: Response, next: NextFunction) => {
      try {
        const { feedbackId } = req.params;
        const userId = req.user?.id;
        const files = req.files as MulterFile[];

        logger.info(`Attachment upload request - feedbackId: ${feedbackId}, userId: ${userId}, files: ${files?.length || 0}`);

        if (!files || files.length === 0) {
          return res.status(400).json({
            success: false,
            error: { code: 'NO_FILES', message: 'No files provided' },
          });
        }

        // Upload files sequentially to handle failures gracefully
        const attachments = [];
        const uploadedIds = [];

        try {
          for (const file of files) {
            const attachment = await this.service.upload(feedbackId, file, userId);
            attachments.push(attachment);
            uploadedIds.push(attachment.id);
          }
        } catch (uploadError) {
          // If partial failure, log but don't cleanup (already uploaded files are valid)
          logger.warn(`Partial upload failure after ${attachments.length} files: ${(uploadError as Error).message}`);
          if (attachments.length === 0) {
            throw uploadError; // Complete failure
          }
          // Return partial success with warning
          return res.status(207).json({
            success: true,
            data: attachments,
            warning: `Only ${attachments.length} of ${files.length} files uploaded successfully`
          });
        }

        res.status(201).json({ success: true, data: attachments });
      } catch (error) {
        next(error);
      }
    };

    list = async (req: Request, res: Response, next: NextFunction) => {
      try {
        const { feedbackId } = req.params;
        const userId = req.user?.id;

        const attachments = await this.service.list(feedbackId, userId);
        res.json({ success: true, data: attachments });
      } catch (error) {
        next(error);
      }
    };

    download = async (req: Request, res: Response, next: NextFunction) => {
      try {
        const { id } = req.params;
        const userId = req.user?.id;

        const result = await this.service.getDownloadUrl(id, userId);
        res.json({ success: true, data: result });
      } catch (error) {
        next(error);
      }
    };

    streamFile = async (req: Request, res: Response, next: NextFunction) => {
      try {
        const { id } = req.params;
        const userId = req.user?.id;

        const { buffer, attachment } = await this.service.getLocalFile(id, userId);

        const safeFilename = attachment.originalName
          .replace(/[^\w\s.-]/g, '_')
          .replace(/"/g, '\\"');

        res.setHeader('Content-Type', attachment.mimeType);
        res.setHeader('Content-Disposition', `attachment; filename="${safeFilename}"`);
        res.setHeader('Content-Length', buffer.length);
        res.send(buffer);
      } catch (error) {
        next(error);
      }
    };

    delete = async (req: Request, res: Response, next: NextFunction) => {
      try {
        const { id } = req.params;
        const userId = req.user?.id;

        if (!userId) {
          return res.status(401).json({
            success: false,
            error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
          });
        }

        await this.service.delete(id, userId);
        res.json({ success: true, data: { deleted: true } });
      } catch (error) {
        next(error);
      }
    };
  }
