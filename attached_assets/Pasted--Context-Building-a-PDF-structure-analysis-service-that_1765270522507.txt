## Context
Building a PDF structure analysis service that analyzes document structure for accessibility compliance. This includes heading hierarchy, table structure, lists, reading order, and tagged PDF structure tree analysis. This is the foundation for WCAG validation.

## Current State
- US-2.4.1 complete with PDFParserService
- US-2.4.2 complete with TextExtractorService
- US-2.4.3 complete with ImageExtractorService
- Need comprehensive structure analysis for accessibility checks

## Objective
Create a structure analysis service that validates heading hierarchy, table accessibility, list structure, reading order, and provides a complete accessibility structure report.

## Technical Requirements

**Create `src/services/pdf/structure-analyzer.service.ts`:**
```typescript
import * as pdfjsLib from 'pdfjs-dist';
import { PDFDocument, PDFName, PDFDict, PDFArray, PDFString, PDFNumber } from 'pdf-lib';
import { pdfParserService, ParsedPDF } from './pdf-parser.service.js';
import { textExtractorService, TextLine, TextBlock } from './text-extractor.service.js';

export interface HeadingInfo {
  id: string;
  level: number;
  text: string;
  pageNumber: number;
  position: { x: number; y: number };
  isFromTags: boolean;
  isProperlyNested: boolean;
}

export interface HeadingHierarchy {
  headings: HeadingInfo[];
  hasProperHierarchy: boolean;
  hasH1: boolean;
  multipleH1: boolean;
  skippedLevels: Array<{ from: number; to: number; location: string }>;
  issues: Array<{
    type: 'missing-h1' | 'multiple-h1' | 'skipped-level' | 'improper-nesting';
    severity: 'critical' | 'major' | 'minor';
    description: string;
    location: string;
    wcagCriterion: string;
  }>;
}

export interface TableCell {
  row: number;
  column: number;
  text: string;
  isHeader: boolean;
  rowSpan: number;
  colSpan: number;
}

export interface TableInfo {
  id: string;
  pageNumber: number;
  position: { x: number; y: number; width: number; height: number };
  rowCount: number;
  columnCount: number;
  hasHeaderRow: boolean;
  hasHeaderColumn: boolean;
  hasSummary: boolean;
  summary?: string;
  caption?: string;
  cells: TableCell[];
  issues: string[];
  isAccessible: boolean;
}

export interface ListInfo {
  id: string;
  pageNumber: number;
  type: 'ordered' | 'unordered' | 'definition';
  itemCount: number;
  items: Array<{
    text: string;
    marker?: string;
    nested?: ListInfo;
  }>;
  position: { x: number; y: number };
  isProperlyTagged: boolean;
}

export interface LinkInfo {
  id: string;
  pageNumber: number;
  text: string;
  url?: string;
  destination?: number;
  position: { x: number; y: number; width: number; height: number };
  hasDescriptiveText: boolean;
  issues: string[];
}

export interface ReadingOrderInfo {
  isLogical: boolean;
  hasStructureTree: boolean;
  issues: Array<{
    type: 'visual-order' | 'column-confusion' | 'float-interruption' | 'table-reading';
    description: string;
    pageNumber: number;
    location?: string;
  }>;
  confidence: number;
}

export interface LanguageInfo {
  documentLanguage?: string;
  hasDocumentLanguage: boolean;
  languageChanges: Array<{
    language: string;
    pageNumber: number;
    text: string;
  }>;
  issues: string[];
}

export interface DocumentStructure {
  isTaggedPDF: boolean;
  headings: HeadingHierarchy;
  tables: TableInfo[];
  lists: ListInfo[];
  links: LinkInfo[];
  readingOrder: ReadingOrderInfo;
  language: LanguageInfo;
  bookmarks: Array<{ title: string; page?: number; level: number }>;
  formFields: Array<{ name: string; type: string; hasLabel: boolean }>;
  accessibilityScore: number;
  summary: {
    totalHeadings: number;
    totalTables: number;
    totalLists: number;
    totalLinks: number;
    totalImages: number;
    totalFormFields: number;
    criticalIssues: number;
    majorIssues: number;
    minorIssues: number;
  };
}

export interface AnalysisOptions {
  analyzeHeadings?: boolean;
  analyzeTables?: boolean;
  analyzeLists?: boolean;
  analyzeLinks?: boolean;
  analyzeReadingOrder?: boolean;
  analyzeLanguage?: boolean;
  pageRange?: { start: number; end: number };
}

class StructureAnalyzerService {
  /**
   * Perform complete structure analysis on a PDF
   */
  async analyzeStructure(
    parsedPdf: ParsedPDF,
    options: AnalysisOptions = {}
  ): Promise<DocumentStructure> {
    const {
      analyzeHeadings = true,
      analyzeTables = true,
      analyzeLists = true,
      analyzeLinks = true,
      analyzeReadingOrder = true,
      analyzeLanguage = true,
      pageRange,
    } = options;

    const isTaggedPDF = parsedPdf.structure.metadata.isTagged;
    
    // Extract text for analysis
    const documentText = await textExtractorService.extractText(parsedPdf, {
      pageRange,
      groupIntoLines: true,
      groupIntoBlocks: true,
    });

    // Analyze each component
    const headings = analyzeHeadings
      ? await this.analyzeHeadings(parsedPdf, documentText, isTaggedPDF)
      : this.emptyHeadingHierarchy();

    const tables = analyzeTables
      ? await this.analyzeTables(parsedPdf, documentText, isTaggedPDF)
      : [];

    const lists = analyzeLists
      ? await this.analyzeLists(parsedPdf, documentText, isTaggedPDF)
      : [];

    const links = analyzeLinks
      ? await this.analyzeLinks(parsedPdf)
      : [];

    const readingOrder = analyzeReadingOrder
      ? await this.analyzeReadingOrder(parsedPdf, documentText, isTaggedPDF)
      : { isLogical: false, hasStructureTree: false, issues: [], confidence: 0 };

    const language = analyzeLanguage
      ? this.analyzeLanguage(parsedPdf, documentText)
      : { hasDocumentLanguage: false, languageChanges: [], issues: [] };

    // Get bookmarks
    const bookmarks = this.extractBookmarks(parsedPdf);

    // Get form fields
    const formFields = await this.analyzeFormFields(parsedPdf);

    // Calculate summary
    const summary = this.calculateSummary(headings, tables, lists, links, formFields);

    // Calculate accessibility score
    const accessibilityScore = this.calculateAccessibilityScore(
      isTaggedPDF,
      headings,
      tables,
      lists,
      links,
      readingOrder,
      language,
      summary
    );

    return {
      isTaggedPDF,
      headings,
      tables,
      lists,
      links,
      readingOrder,
      language,
      bookmarks,
      formFields,
      accessibilityScore,
      summary,
    };
  }

  /**
   * Analyze heading structure
   */
  private async analyzeHeadings(
    parsedPdf: ParsedPDF,
    documentText: any,
    isTaggedPDF: boolean
  ): Promise<HeadingHierarchy> {
    const headings: HeadingInfo[] = [];
    const issues: HeadingHierarchy['issues'] = [];

    // Extract headings from text analysis (font-size based)
    for (const page of documentText.pages) {
      for (const line of page.lines) {
        if (line.isHeading && line.headingLevel) {
          headings.push({
            id: `h_p${page.pageNumber}_${headings.length}`,
            level: line.headingLevel,
            text: line.text.substring(0, 200),
            pageNumber: page.pageNumber,
            position: { x: line.boundingBox.x, y: line.boundingBox.y },
            isFromTags: false,
            isProperlyNested: true, // Will be updated below
          });
        }
      }
    }

    // If tagged PDF, also try to get headings from structure tree
    if (isTaggedPDF) {
      const taggedHeadings = await this.extractTaggedHeadings(parsedPdf);
      // Merge or prefer tagged headings
      if (taggedHeadings.length > 0) {
        // Use tagged headings as they're more reliable
        headings.length = 0;
        headings.push(...taggedHeadings);
      }
    }

    // Sort by page and position
    headings.sort((a, b) => {
      if (a.pageNumber !== b.pageNumber) return a.pageNumber - b.pageNumber;
      return a.position.y - b.position.y;
    });

    // Analyze hierarchy
    const hasH1 = headings.some(h => h.level === 1);
    const h1Count = headings.filter(h => h.level === 1).length;
    const multipleH1 = h1Count > 1;
    const skippedLevels: HeadingHierarchy['skippedLevels'] = [];

    // Check for missing H1
    if (!hasH1 && headings.length > 0) {
      issues.push({
        type: 'missing-h1',
        severity: 'major',
        description: 'Document has no H1 heading. Every document should have a main heading.',
        location: 'Document',
        wcagCriterion: '1.3.1',
      });
    }

    // Check for multiple H1s
    if (multipleH1) {
      issues.push({
        type: 'multiple-h1',
        severity: 'minor',
        description: `Document has ${h1Count} H1 headings. Consider using only one main heading.`,
        location: 'Document',
        wcagCriterion: '1.3.1',
      });
    }

    // Check for skipped levels
    let previousLevel = 0;
    for (let i = 0; i < headings.length; i++) {
      const heading = headings[i];
      
      if (previousLevel > 0 && heading.level > previousLevel + 1) {
        const skip = { from: previousLevel, to: heading.level, location: `Page ${heading.pageNumber}` };
        skippedLevels.push(skip);
        headings[i].isProperlyNested = false;
        
        issues.push({
          type: 'skipped-level',
          severity: 'major',
          description: `Heading level skipped from H${previousLevel} to H${heading.level}: "${heading.text.substring(0, 50)}..."`,
          location: `Page ${heading.pageNumber}`,
          wcagCriterion: '1.3.1',
        });
      }
      
      previousLevel = heading.level;
    }

    const hasProperHierarchy = issues.filter(i => i.severity !== 'minor').length === 0;

    return {
      headings,
      hasProperHierarchy,
      hasH1,
      multipleH1,
      skippedLevels,
      issues,
    };
  }

  /**
   * Extract headings from tagged PDF structure tree
   */
  private async extractTaggedHeadings(parsedPdf: ParsedPDF): Promise<HeadingInfo[]> {
    const headings: HeadingInfo[] = [];
    
    try {
      const catalog = parsedPdf.pdfLibDoc.context.lookup(
        parsedPdf.pdfLibDoc.context.trailerInfo.Root
      );
      
      if (catalog instanceof PDFDict) {
        const structTreeRoot = catalog.get(PDFName.of('StructTreeRoot'));
        if (structTreeRoot instanceof PDFDict) {
          await this.traverseStructureTree(
            structTreeRoot,
            parsedPdf.pdfLibDoc,
            headings,
            1
          );
        }
      }
    } catch (err) {
      // Ignore structure tree errors
    }
    
    return headings;
  }

  /**
   * Traverse PDF structure tree to find headings
   */
  private async traverseStructureTree(
    node: PDFDict,
    pdfDoc: PDFDocument,
    headings: HeadingInfo[],
    pageNumber: number
  ): Promise<void> {
    try {
      const type = node.get(PDFName.of('S'))?.toString();
      
      // Check for heading tags (H, H1-H6)
      if (type && /^\/H[1-6]?$/.test(type)) {
        const level = type === '/H' ? 1 : parseInt(type.replace('/H', ''), 10);
        
        // Try to get text content
        let text = '';
        const kids = node.get(PDFName.of('K'));
        if (kids instanceof PDFString) {
          text = kids.decodeText();
        }
        
        headings.push({
          id: `h_tagged_${headings.length}`,
          level,
          text: text || `Heading ${headings.length + 1}`,
          pageNumber,
          position: { x: 0, y: 0 },
          isFromTags: true,
          isProperlyNested: true,
        });
      }
      
      // Recurse into children
      const kids = node.get(PDFName.of('K'));
      if (kids instanceof PDFArray) {
        for (let i = 0; i < kids.size(); i++) {
          const kid = kids.get(i);
          if (kid instanceof PDFDict) {
            await this.traverseStructureTree(kid, pdfDoc, headings, pageNumber);
          } else {
            const resolved = pdfDoc.context.lookup(kid);
            if (resolved instanceof PDFDict) {
              await this.traverseStructureTree(resolved, pdfDoc, headings, pageNumber);
            }
          }
        }
      }
    } catch {
      // Ignore traversal errors
    }
  }

  /**
   * Analyze table structure
   */
  private async analyzeTables(
    parsedPdf: ParsedPDF,
    documentText: any,
    isTaggedPDF: boolean
  ): Promise<TableInfo[]> {
    const tables: TableInfo[] = [];
    
    // Detect tables from text blocks with tabular patterns
    for (const page of documentText.pages) {
      const potentialTables = this.detectTabularContent(page.blocks, page.pageNumber);
      tables.push(...potentialTables);
    }

    // If tagged PDF, enhance with structure tree info
    if (isTaggedPDF) {
      await this.enhanceTablesFromTags(parsedPdf, tables);
    }

    // Validate each table
    for (const table of tables) {
      this.validateTableAccessibility(table);
    }

    return tables;
  }

  /**
   * Detect tabular content from text blocks
   */
  private detectTabularContent(blocks: TextBlock[], pageNumber: number): TableInfo[] {
    const tables: TableInfo[] = [];
    
    // Simple heuristic: look for blocks with consistent column alignment
    for (const block of blocks) {
      if (block.lines.length >= 2) {
        // Check if lines have similar column positions
        const columnPositions = this.detectColumnPositions(block.lines);
        
        if (columnPositions.length >= 2) {
          const table: TableInfo = {
            id: `table_p${pageNumber}_${tables.length}`,
            pageNumber,
            position: block.boundingBox,
            rowCount: block.lines.length,
            columnCount: columnPositions.length,
            hasHeaderRow: false,
            hasHeaderColumn: false,
            hasSummary: false,
            cells: [],
            issues: [],
            isAccessible: false,
          };
          
          // Check if first row looks like headers (bold or different style)
          if (block.lines[0]?.items.some(i => i.font.isBold)) {
            table.hasHeaderRow = true;
          }
          
          tables.push(table);
        }
      }
    }
    
    return tables;
  }

  /**
   * Detect column positions from text lines
   */
  private detectColumnPositions(lines: TextLine[]): number[] {
    const allXPositions: number[] = [];
    
    for (const line of lines) {
      for (const item of line.items) {
        allXPositions.push(Math.round(item.position.x / 10) * 10); // Round to nearest 10
      }
    }
    
    // Find common X positions
    const positionCounts = new Map<number, number>();
    for (const x of allXPositions) {
      positionCounts.set(x, (positionCounts.get(x) || 0) + 1);
    }
    
    // Positions that appear in most rows are likely column starts
    const threshold = lines.length * 0.5;
    const columns = Array.from(positionCounts.entries())
      .filter(([_, count]) => count >= threshold)
      .map(([pos]) => pos)
      .sort((a, b) => a - b);
    
    return columns;
  }

  /**
   * Enhance tables with tagged PDF info
   */
  private async enhanceTablesFromTags(parsedPdf: ParsedPDF, tables: TableInfo[]): Promise<void> {
    // Implementation would traverse structure tree for Table tags
    // and extract TH/TD structure
  }

  /**
   * Validate table accessibility
   */
  private validateTableAccessibility(table: TableInfo): void {
    if (!table.hasHeaderRow && !table.hasHeaderColumn) {
      table.issues.push('Table has no header cells (TH). Add row or column headers.');
    }
    
    if (table.rowCount > 5 && !table.hasSummary) {
      table.issues.push('Complex table should have a summary describing its structure.');
    }
    
    table.isAccessible = table.issues.length === 0 && (table.hasHeaderRow || table.hasHeaderColumn);
  }

  /**
   * Analyze list structure
   */
  private async analyzeLists(
    parsedPdf: ParsedPDF,
    documentText: any,
    isTaggedPDF: boolean
  ): Promise<ListInfo[]> {
    const lists: ListInfo[] = [];
    const bulletPatterns = /^[\u2022\u2023\u25E6\u2043\u2219•◦‣⁃○●\-\*]\s/;
    const numberPatterns = /^(\d+[\.\)]\s|[a-z][\.\)]\s|[ivxlcdm]+[\.\)]\s)/i;
    
    for (const page of documentText.pages) {
      let currentList: ListInfo | null = null;
      
      for (const block of page.blocks) {
        if (block.type === 'list') {
          const listItems: ListInfo['items'] = [];
          let listType: ListInfo['type'] = 'unordered';
          
          for (const line of block.lines) {
            const text = line.text.trim();
            let marker = '';
            let itemText = text;
            
            if (bulletPatterns.test(text)) {
              marker = text.match(bulletPatterns)?.[0] || '';
              itemText = text.replace(bulletPatterns, '');
              listType = 'unordered';
            } else if (numberPatterns.test(text)) {
              marker = text.match(numberPatterns)?.[0] || '';
              itemText = text.replace(numberPatterns, '');
              listType = 'ordered';
            }
            
            listItems.push({ text: itemText, marker });
          }
          
          if (listItems.length > 0) {
            lists.push({
              id: `list_p${page.pageNumber}_${lists.length}`,
              pageNumber: page.pageNumber,
              type: listType,
              itemCount: listItems.length,
              items: listItems,
              position: { x: block.boundingBox.x, y: block.boundingBox.y },
              isProperlyTagged: isTaggedPDF, // Assume tagged if PDF is tagged
            });
          }
        }
      }
    }
    
    return lists;
  }

  /**
   * Analyze links
   */
  private async analyzeLinks(parsedPdf: ParsedPDF): Promise<LinkInfo[]> {
    const links: LinkInfo[] = [];
    
    for (let pageNum = 1; pageNum <= parsedPdf.structure.pageCount; pageNum++) {
      try {
        const page = await parsedPdf.pdfjsDoc.getPage(pageNum);
        const annotations = await page.getAnnotations();
        const viewport = page.getViewport({ scale: 1 });
        
        for (const annot of annotations) {
          if (annot.subtype === 'Link') {
            const rect = annot.rect || [0, 0, 0, 0];
            const link: LinkInfo = {
              id: `link_p${pageNum}_${links.length}`,
              pageNumber: pageNum,
              text: annot.contents || '',
              url: annot.url || undefined,
              destination: typeof annot.dest === 'number' ? annot.dest : undefined,
              position: {
                x: rect[0],
                y: viewport.height - rect[3],
                width: rect[2] - rect[0],
                height: rect[3] - rect[1],
              },
              hasDescriptiveText: false,
              issues: [],
            };
            
            // Check for descriptive text
            if (link.text && link.text.length > 3 && !/^(click|here|link|more)$/i.test(link.text)) {
              link.hasDescriptiveText = true;
            } else {
              link.issues.push('Link text is not descriptive (WCAG 2.4.4)');
            }
            
            links.push(link);
          }
        }
      } catch {
        // Ignore page errors
      }
    }
    
    return links;
  }

  /**
   * Analyze reading order
   */
  private async analyzeReadingOrder(
    parsedPdf: ParsedPDF,
    documentText: any,
    isTaggedPDF: boolean
  ): Promise<ReadingOrderInfo> {
    const issues: ReadingOrderInfo['issues'] = [];
    let confidence = 0.5;
    
    if (isTaggedPDF) {
      confidence = 0.9;
    }
    
    // Check for multi-column layouts
    for (const page of documentText.pages) {
      const columnGroups = this.detectColumns(page.lines);
      
      if (columnGroups.length > 1 && !isTaggedPDF) {
        issues.push({
          type: 'column-confusion',
          description: 'Multi-column layout detected without proper tagging. Reading order may be incorrect.',
          pageNumber: page.pageNumber,
        });
        confidence -= 0.2;
      }
    }
    
    return {
      isLogical: issues.length === 0 && (isTaggedPDF || documentText.readingOrder === 'left-to-right'),
      hasStructureTree: isTaggedPDF,
      issues,
      confidence: Math.max(0, Math.min(1, confidence)),
    };
  }

  /**
   * Detect column layout
   */
  private detectColumns(lines: TextLine[]): number[][] {
    if (lines.length === 0) return [];
    
    // Group lines by their X position ranges
    const xRanges: Array<{ minX: number; maxX: number; lines: TextLine[] }> = [];
    
    for (const line of lines) {
      const lineMinX = line.boundingBox.x;
      const lineMaxX = line.boundingBox.x + line.boundingBox.width;
      
      let foundGroup = false;
      for (const range of xRanges) {
        // Check for overlap
        if (lineMinX < range.maxX + 50 && lineMaxX > range.minX - 50) {
          range.minX = Math.min(range.minX, lineMinX);
          range.maxX = Math.max(range.maxX, lineMaxX);
          range.lines.push(line);
          foundGroup = true;
          break;
        }
      }
      
      if (!foundGroup) {
        xRanges.push({ minX: lineMinX, maxX: lineMaxX, lines: [line] });
      }
    }
    
    // Return column groups with significant content
    return xRanges
      .filter(r => r.lines.length >= 3)
      .map(r => r.lines.map(l => lines.indexOf(l)));
  }

  /**
   * Analyze document language
   */
  private analyzeLanguage(parsedPdf: ParsedPDF, documentText: any): LanguageInfo {
    const issues: string[] = [];
    const documentLanguage = parsedPdf.structure.metadata.language;
    
    if (!documentLanguage) {
      issues.push('Document language is not set (WCAG 3.1.1). Screen readers may not pronounce content correctly.');
    }
    
    return {
      documentLanguage,
      hasDocumentLanguage: !!documentLanguage,
      languageChanges: [], // Would require more sophisticated analysis
      issues,
    };
  }

  /**
   * Extract bookmarks
   */
  private extractBookmarks(parsedPdf: ParsedPDF): Array<{ title: string; page?: number; level: number }> {
    const bookmarks: Array<{ title: string; page?: number; level: number }> = [];
    
    if (parsedPdf.structure.outline) {
      const flattenOutline = (
        items: typeof parsedPdf.structure.outline,
        level: number
      ) => {
        for (const item of items || []) {
          bookmarks.push({
            title: item.title,
            page: item.destination,
            level,
          });
          if (item.children) {
            flattenOutline(item.children, level + 1);
          }
        }
      };
      
      flattenOutline(parsedPdf.structure.outline, 1);
    }
    
    return bookmarks;
  }

  /**
   * Analyze form fields
   */
  private async analyzeFormFields(
    parsedPdf: ParsedPDF
  ): Promise<Array<{ name: string; type: string; hasLabel: boolean }>> {
    const fields: Array<{ name: string; type: string; hasLabel: boolean }> = [];
    
    if (!parsedPdf.structure.metadata.hasAcroForm) {
      return fields;
    }
    
    // Would extract form field info from AcroForm
    // Simplified implementation
    
    return fields;
  }

  /**
   * Calculate summary statistics
   */
  private calculateSummary(
    headings: HeadingHierarchy,
    tables: TableInfo[],
    lists: ListInfo[],
    links: LinkInfo[],
    formFields: Array<{ name: string; type: string; hasLabel: boolean }>
  ): DocumentStructure['summary'] {
    let criticalIssues = 0;
    let majorIssues = 0;
    let minorIssues = 0;
    
    // Count heading issues
    for (const issue of headings.issues) {
      if (issue.severity === 'critical') criticalIssues++;
      else if (issue.severity === 'major') majorIssues++;
      else minorIssues++;
    }
    
    // Count table issues
    for (const table of tables) {
      majorIssues += table.issues.length;
    }
    
    // Count link issues
    for (const link of links) {
      minorIssues += link.issues.length;
    }
    
    return {
      totalHeadings: headings.headings.length,
      totalTables: tables.length,
      totalLists: lists.length,
      totalLinks: links.length,
      totalImages: 0, // Would be filled by image extraction
      totalFormFields: formFields.length,
      criticalIssues,
      majorIssues,
      minorIssues,
    };
  }

  /**
   * Calculate overall accessibility score
   */
  private calculateAccessibilityScore(
    isTaggedPDF: boolean,
    headings: HeadingHierarchy,
    tables: TableInfo[],
    lists: ListInfo[],
    links: LinkInfo[],
    readingOrder: ReadingOrderInfo,
    language: LanguageInfo,
    summary: DocumentStructure['summary']
  ): number {
    let score = 100;
    
    // Tagged PDF is essential
    if (!isTaggedPDF) score -= 30;
    
    // Language
    if (!language.hasDocumentLanguage) score -= 10;
    
    // Headings
    if (!headings.hasH1) score -= 10;
    if (!headings.hasProperHierarchy) score -= 15;
    
    // Tables
    const inaccessibleTables = tables.filter(t => !t.isAccessible).length;
    score -= inaccessibleTables * 5;
    
    // Links
    const badLinks = links.filter(l => !l.hasDescriptiveText).length;
    score -= Math.min(badLinks * 2, 10);
    
    // Reading order
    if (!readingOrder.isLogical) score -= 10;
    
    // Issue penalties
    score -= summary.criticalIssues * 10;
    score -= summary.majorIssues * 5;
    score -= summary.minorIssues * 1;
    
    return Math.max(0, Math.min(100, score));
  }

  /**
   * Empty heading hierarchy for when analysis is skipped
   */
  private emptyHeadingHierarchy(): HeadingHierarchy {
    return {
      headings: [],
      hasProperHierarchy: true,
      hasH1: false,
      multipleH1: false,
      skippedLevels: [],
      issues: [],
    };
  }

  /**
   * Analyze from file path (convenience method)
   */
  async analyzeFromFile(
    filePath: string,
    options: AnalysisOptions = {}
  ): Promise<DocumentStructure> {
    const parsedPdf = await pdfParserService.parse(filePath);
    try {
      return await this.analyzeStructure(parsedPdf, options);
    } finally {
      await pdfParserService.close(parsedPdf);
    }
  }
}

export const structureAnalyzerService = new StructureAnalyzerService();
```

**Update `src/routes/pdf.routes.ts` to add structure analysis endpoints:**

Add import at top:
```typescript
import { structureAnalyzerService } from '../services/pdf/structure-analyzer.service.js';
```

Add new endpoints:
```typescript
// Full structure analysis
router.post('/analyze-structure', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { filePath, options = {} } = req.body;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { message: 'filePath is required' },
      });
    }

    const structure = await structureAnalyzerService.analyzeFromFile(filePath, options);

    res.json({
      success: true,
      data: structure,
    });
  } catch (error) {
    next(error);
  }
});

// Heading analysis only
router.post('/analyze-headings', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { filePath } = req.body;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { message: 'filePath is required' },
      });
    }

    const structure = await structureAnalyzerService.analyzeFromFile(filePath, {
      analyzeHeadings: true,
      analyzeTables: false,
      analyzeLists: false,
      analyzeLinks: false,
      analyzeReadingOrder: false,
      analyzeLanguage: false,
    });

    res.json({
      success: true,
      data: structure.headings,
    });
  } catch (error) {
    next(error);
  }
});

// Accessibility score only
router.post('/accessibility-score', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { filePath } = req.body;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { message: 'filePath is required' },
      });
    }

    const structure = await structureAnalyzerService.analyzeFromFile(filePath);

    res.json({
      success: true,
      data: {
        score: structure.accessibilityScore,
        isTaggedPDF: structure.isTaggedPDF,
        summary: structure.summary,
        topIssues: [
          ...structure.headings.issues.slice(0, 3),
          ...structure.language.issues.map(i => ({ type: 'language', severity: 'major', description: i })),
        ].slice(0, 5),
      },
    });
  } catch (error) {
    next(error);
  }
});
```

## Tasks
1. Create src/services/pdf/structure-analyzer.service.ts
2. Update src/routes/pdf.routes.ts with structure analysis endpoints
3. Verify server starts without errors
4. Test structure analysis with a sample PDF if available

## Acceptance Criteria
- [ ] StructureAnalyzerService analyzes PDF structure
- [ ] Heading hierarchy analysis with issue detection
- [ ] Table accessibility validation
- [ ] List structure detection
- [ ] Link analysis with descriptive text checking
- [ ] Reading order assessment
- [ ] Language declaration checking
- [ ] Accessibility score calculation
- [ ] /api/v1/pdf/analyze-structure endpoint working
- [ ] /api/v1/pdf/analyze-headings endpoint working
- [ ] /api/v1/pdf/accessibility-score endpoint working
- [ ] Server starts without errors