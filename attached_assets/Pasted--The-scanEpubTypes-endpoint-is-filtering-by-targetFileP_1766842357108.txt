 The scanEpubTypes endpoint is filtering by targetFilePath, but epub:type attributes exist in files OTHER than the reported issue location. For example, the issue is reported on wasteland-content.xhtml but the actual epub:type attributes (toc, landmarks, frontmatter, etc.) are in wasteland-nav.xhtml and other files.

  Solution

  Remove the file path filtering from scanEpubTypes - scan ALL XHTML files in the EPUB.

  ---
  Backend Change

  File: src/services/epub/epub-modifier.service.ts

  Find the scanEpubTypes method and remove any file path filtering logic. The method should scan ALL XHTML files without filtering:

  async scanEpubTypes(zip: JSZip): Promise<{
    epubTypes: Array<{
      value: string;
      file: string;
      count: number;
      suggestedRole: string;
      elementType: string;
    }>;
    files: string[];
  }> {
    const epubTypeMap = new Map<string, {
      value: string;
      files: Set<string>;
      count: number;
      elementType: string;
    }>();
    const scannedFiles: string[] = [];

    const roleMapping: Record<string, string> = {
      'chapter': 'doc-chapter',
      'part': 'doc-part',
      'toc': 'doc-toc',
      'nav': 'navigation',
      'landmarks': 'navigation',
      'frontmatter': 'doc-prologue',
      'bodymatter': 'main',
      'backmatter': 'doc-epilogue',
      'titlepage': 'doc-cover',
      'dedication': 'doc-dedication',
      'epigraph': 'doc-epigraph',
      'foreword': 'doc-foreword',
      'preface': 'doc-preface',
      'introduction': 'doc-introduction',
      'prologue': 'doc-prologue',
      'epilogue': 'doc-epilogue',
      'afterword': 'doc-afterword',
      'appendix': 'doc-appendix',
      'glossary': 'doc-glossary',
      'bibliography': 'doc-bibliography',
      'index': 'doc-index',
      'colophon': 'doc-colophon',
      'acknowledgments': 'doc-acknowledgments',
      'noteref': 'doc-noteref',
      'footnote': 'doc-footnote',
      'endnote': 'doc-endnote',
      'rearnote': 'doc-endnote',
      'rearnotes': 'doc-endnotes',
      'footnotes': 'doc-footnotes',
      'endnotes': 'doc-endnotes',
      'pagebreak': 'doc-pagebreak',
      'page-list': 'doc-pagelist',
      'cover': 'doc-cover',
    };

    // Scan ALL XHTML files - no filtering
    const xhtmlFiles = Object.keys(zip.files).filter(path =>
      /\.(xhtml|html|htm)$/i.test(path) && !zip.files[path].dir
    );

    for (const filePath of xhtmlFiles) {
      try {
        const content = await zip.file(filePath)?.async('text');
        if (!content) continue;

        scannedFiles.push(filePath);
        const $ = cheerio.load(content, { xml: true });

        $('[epub\\:type]').each((_, elem) => {
          const epubTypeAttr = $(elem).attr('epub:type');
          if (!epubTypeAttr) return;

          const types = epubTypeAttr.trim().split(/\s+/);
          const elementType = elem.tagName?.toLowerCase() || 'unknown';

          for (const type of types) {
            const normalizedType = type.toLowerCase();
            const existing = epubTypeMap.get(normalizedType);

            if (existing) {
              existing.files.add(filePath);
              existing.count++;
            } else {
              epubTypeMap.set(normalizedType, {
                value: type,
                files: new Set([filePath]),
                count: 1,
                elementType,
              });
            }
          }
        });
      } catch (err) {
        console.warn(`Failed to parse ${filePath}:`, err);
      }
    }

    const epubTypes = Array.from(epubTypeMap.entries()).map(([key, data]) => ({
      value: data.value,
      file: Array.from(data.files).join(', '),
      count: data.count,
      suggestedRole: roleMapping[key] || 'region',
      elementType: data.elementType,
    }));

    return {
      epubTypes: epubTypes.sort((a, b) => b.count - a.count),
      files: scannedFiles,
    };
  }

  ---
  File: src/controllers/epub.controller.ts

  Update the controller to NOT pass filePath to the scan method:

  async scanEpubTypes(req: AuthenticatedRequest, res: Response) {
    try {
      const { jobId } = req.params;
      const tenantId = req.user?.tenantId;

      if (!tenantId) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const job = await prisma.job.findFirst({ where: { id: jobId, tenantId } });
      if (!job) {
        return res.status(404).json({ success: false, error: 'Job not found' });
      }

      const input = job.input as { fileName?: string } | null;
      const fileName = input?.fileName || 'document.epub';

      let epubBuffer = await fileStorageService.getRemediatedFile(
        jobId,
        fileName.replace(/\.epub$/i, '_remediated.epub')
      );
      if (!epubBuffer) {
        epubBuffer = await fileStorageService.getFile(jobId, fileName);
      }

      if (!epubBuffer) {
        return res.status(404).json({ success: false, error: 'EPUB file not found' });
      }

      const zip = await epubModifier.loadEPUB(epubBuffer);
      // No filePath parameter - scan entire EPUB
      const result = await epubModifier.scanEpubTypes(zip);

      return res.json({ success: true, data: result });
    } catch (error) {
      console.error('Failed to scan epub:type values:', error);
      return res.status(500).json({
        success: false,
        error: error instanceof Error ? error.message : 'Failed to scan epub:type values',
      });
    }
  },
