 Prompt 32: Debug epub:type Scanning

  Step 1: Add Backend Logging

  File: src/services/epub/epub-modifier.service.ts

  Replace the scanEpubTypes method with this version that has detailed logging:

  async scanEpubTypes(zip: JSZip): Promise<{
    epubTypes: Array<{
      value: string;
      file: string;
      count: number;
      suggestedRole: string;
      elementType: string;
    }>;
    files: string[];
  }> {
    console.log('=== scanEpubTypes START ===');

    const epubTypeMap = new Map<string, {
      value: string;
      files: Set<string>;
      count: number;
      elementType: string;
    }>();
    const scannedFiles: string[] = [];

    const roleMapping: Record<string, string> = {
      'chapter': 'doc-chapter',
      'part': 'doc-part',
      'toc': 'doc-toc',
      'nav': 'navigation',
      'landmarks': 'navigation',
      'frontmatter': 'doc-prologue',
      'bodymatter': 'main',
      'backmatter': 'doc-epilogue',
      'titlepage': 'doc-cover',
      'dedication': 'doc-dedication',
      'epigraph': 'doc-epigraph',
      'noteref': 'doc-noteref',
      'rearnote': 'doc-endnote',
      'rearnotes': 'doc-endnotes',
    };

    const allFiles = Object.keys(zip.files);
    console.log('All files in EPUB:', allFiles);

    const xhtmlFiles = allFiles.filter(path =>
      /\.(xhtml|html|htm)$/i.test(path) && !zip.files[path].dir
    );
    console.log('XHTML files to scan:', xhtmlFiles);

    for (const filePath of xhtmlFiles) {
      try {
        const content = await zip.file(filePath)?.async('text');
        if (!content) {
          console.log(`No content for ${filePath}`);
          continue;
        }

        console.log(`\n--- Scanning: ${filePath} ---`);
        console.log(`Content length: ${content.length} chars`);

        // Check if epub:type exists in raw content
        const rawMatches = content.match(/epub:type\s*=\s*["'][^"']+["']/g);
        console.log(`Raw epub:type matches in ${filePath}:`, rawMatches);

        scannedFiles.push(filePath);

        // Try multiple cheerio loading options
        const $ = cheerio.load(content, {
          xmlMode: true,
          decodeEntities: false
        });

        // Try different selectors
        const selector1 = $('[epub\\:type]');
        const selector2 = $('*').filter((_, el) => $(el).attr('epub:type') !== undefined);

        console.log(`Selector [epub\\:type] found: ${selector1.length} elements`);
        console.log(`Filter method found: ${selector2.length} elements`);

        // Use the filter method which is more reliable for namespaced attrs
        selector2.each((_, elem) => {
          const epubTypeAttr = $(elem).attr('epub:type');
          console.log(`Found element: <${elem.tagName}> with epub:type="${epubTypeAttr}"`);

          if (!epubTypeAttr) return;

          const types = epubTypeAttr.trim().split(/\s+/);
          const elementType = elem.tagName?.toLowerCase() || 'unknown';

          for (const type of types) {
            const normalizedType = type.toLowerCase();
            const existing = epubTypeMap.get(normalizedType);

            if (existing) {
              existing.files.add(filePath);
              existing.count++;
            } else {
              epubTypeMap.set(normalizedType, {
                value: type,
                files: new Set([filePath]),
                count: 1,
                elementType,
              });
            }
          }
        });
      } catch (err) {
        console.error(`Error parsing ${filePath}:`, err);
      }
    }

    const epubTypes = Array.from(epubTypeMap.entries()).map(([key, data]) => ({
      value: data.value,
      file: Array.from(data.files).join(', '),
      count: data.count,
      suggestedRole: roleMapping[key] || 'region',
      elementType: data.elementType,
    }));

    console.log('\n=== scanEpubTypes RESULT ===');
    console.log('Total unique epub:types found:', epubTypes.length);
    console.log('epub:types:', epubTypes);
    console.log('Files scanned:', scannedFiles);

    return {
      epubTypes: epubTypes.sort((a, b) => b.count - a.count),
      files: scannedFiles,
    };
  }

  ---
  Step 2: Verify Route Exists

  File: src/routes/epub.routes.ts

  Make sure this line exists:

  router.get('/job/:jobId/scan-epub-types', authenticate, epubController.scanEpubTypes);

  ---
  Step 3: Verify Controller Method Exists

  File: src/controllers/epub.controller.ts

  Make sure scanEpubTypes is in the controller object and properly exported:

  export const epubController = {
    // ... other methods ...

    async scanEpubTypes(req: AuthenticatedRequest, res: Response) {
      console.log('=== scanEpubTypes endpoint called ===');
      try {
        const { jobId } = req.params;
        const tenantId = req.user?.tenantId;

        console.log('jobId:', jobId);
        console.log('tenantId:', tenantId);

        if (!tenantId) {
          return res.status(401).json({ success: false, error: 'Authentication required' });
        }

        const job = await prisma.job.findFirst({ where: { id: jobId, tenantId } });
        if (!job) {
          console.log('Job not found');
          return res.status(404).json({ success: false, error: 'Job not found' });
        }

        const input = job.input as { fileName?: string } | null;
        const fileName = input?.fileName || 'document.epub';
        console.log('fileName:', fileName);

        let epubBuffer = await fileStorageService.getRemediatedFile(
          jobId,
          fileName.replace(/\.epub$/i, '_remediated.epub')
        );
        console.log('Remediated file found:', !!epubBuffer);

        if (!epubBuffer) {
          epubBuffer = await fileStorageService.getFile(jobId, fileName);
          console.log('Original file found:', !!epubBuffer);
        }

        if (!epubBuffer) {
          return res.status(404).json({ success: false, error: 'EPUB file not found' });
        }

        console.log('EPUB buffer size:', epubBuffer.length);

        const zip = await epubModifier.loadEPUB(epubBuffer);
        const result = await epubModifier.scanEpubTypes(zip);

        console.log('Returning result with', result.epubTypes.length, 'epub:types');

        return res.json({ success: true, data: result });
      } catch (error) {
        console.error('scanEpubTypes error:', error);
        return res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : 'Failed to scan',
        });
      }
    },
  };