Prompt 30: Complete epub:type Scanning Implementation

  Here's the complete fix to implement epub:type scanning. Apply these changes in your Replit environment:

  ---
  1. Backend: Add scanEpubTypes to epub-modifier.service.ts

  Add this method to the EPUBModifierService class:

  async scanEpubTypes(zip: JSZip, targetFilePath?: string): Promise<{
    epubTypes: Array<{
      value: string;
      file: string;
      count: number;
      suggestedRole: string;
      elementType: string;
    }>;
    files: string[];
  }> {
    const epubTypeMap = new Map<string, {
      value: string;
      files: Set<string>;
      count: number;
      elementType: string;
    }>();
    const scannedFiles: string[] = [];

    // ARIA role mapping for epub:type values
    const roleMapping: Record<string, string> = {
      'chapter': 'doc-chapter',
      'part': 'doc-part',
      'toc': 'doc-toc',
      'nav': 'navigation',
      'landmarks': 'navigation',
      'frontmatter': 'doc-prologue',
      'bodymatter': 'main',
      'backmatter': 'doc-epilogue',
      'titlepage': 'doc-cover',
      'dedication': 'doc-dedication',
      'epigraph': 'doc-epigraph',
      'foreword': 'doc-foreword',
      'preface': 'doc-preface',
      'introduction': 'doc-introduction',
      'prologue': 'doc-prologue',
      'epilogue': 'doc-epilogue',
      'afterword': 'doc-afterword',
      'appendix': 'doc-appendix',
      'glossary': 'doc-glossary',
      'bibliography': 'doc-bibliography',
      'index': 'doc-index',
      'colophon': 'doc-colophon',
      'acknowledgments': 'doc-acknowledgments',
      'noteref': 'doc-noteref',
      'footnote': 'doc-footnote',
      'endnote': 'doc-endnote',
      'rearnote': 'doc-endnote',
      'rearnotes': 'doc-endnotes',
      'footnotes': 'doc-footnotes',
      'endnotes': 'doc-endnotes',
      'pagebreak': 'doc-pagebreak',
      'page-list': 'doc-pagelist',
      'cover': 'doc-cover',
      'halftitlepage': 'doc-cover',
      'imprint': 'doc-colophon',
      'contributors': 'doc-credits',
      'notice': 'doc-notice',
      'errata': 'doc-errata',
    };

    // Get all XHTML files from the EPUB
    const xhtmlFiles = Object.keys(zip.files).filter(path =>
      /\.(xhtml|html|htm)$/i.test(path) && !zip.files[path].dir
    );

    for (const filePath of xhtmlFiles) {
      // If targetFilePath specified, only scan files matching it
      if (targetFilePath && !filePath.includes(targetFilePath.replace(/^.*\//, ''))) {
        continue;
      }

      try {
        const content = await zip.file(filePath)?.async('text');
        if (!content) continue;

        scannedFiles.push(filePath);
        const $ = cheerio.load(content, { xml: true });

        // Find all elements with epub:type attribute
        $('[epub\\:type]').each((_, elem) => {
          const epubTypeAttr = $(elem).attr('epub:type');
          if (!epubTypeAttr) return;

          // epub:type can have multiple space-separated values
          const types = epubTypeAttr.trim().split(/\s+/);
          const elementType = elem.tagName?.toLowerCase() || 'unknown';

          for (const type of types) {
            const normalizedType = type.toLowerCase();
            const existing = epubTypeMap.get(normalizedType);

            if (existing) {
              existing.files.add(filePath);
              existing.count++;
            } else {
              epubTypeMap.set(normalizedType, {
                value: type,
                files: new Set([filePath]),
                count: 1,
                elementType,
              });
            }
          }
        });
      } catch (err) {
        logger.warn(`Failed to parse ${filePath} for epub:type scanning`, err);
      }
    }

    // Convert map to array
    const epubTypes = Array.from(epubTypeMap.entries()).map(([key, data]) => ({
      value: data.value,
      file: Array.from(data.files).join(', '),
      count: data.count,
      suggestedRole: roleMapping[key] || 'region',
      elementType: data.elementType,
    }));

    return {
      epubTypes: epubTypes.sort((a, b) => b.count - a.count),
      files: scannedFiles,
    };
  }

  ---
  2. Backend: Add controller method to epub.controller.ts

  Add this method to epubController:

  async scanEpubTypes(req: AuthenticatedRequest, res: Response) {
    try {
      const { jobId } = req.params;
      const targetFilePath = req.query.filePath as string | undefined;
      const tenantId = req.user?.tenantId;

      if (!tenantId) {
        return res.status(401).json({
          success: false,
          error: 'Authentication required',
        });
      }

      const job = await prisma.job.findFirst({
        where: { id: jobId, tenantId },
      });

      if (!job) {
        return res.status(404).json({
          success: false,
          error: 'Job not found',
        });
      }

      const input = job.input as { fileName?: string } | null;
      const fileName = input?.fileName || 'document.epub';

      // Try to get remediated file first, fall back to original
      let epubBuffer = await fileStorageService.getRemediatedFile(
        jobId,
        fileName.replace(/\.epub$/i, '_remediated.epub')
      );
      if (!epubBuffer) {
        epubBuffer = await fileStorageService.getFile(jobId, fileName);
      }

      if (!epubBuffer) {
        return res.status(404).json({
          success: false,
          error: 'EPUB file not found',
        });
      }

      const zip = await epubModifier.loadEPUB(epubBuffer);
      const result = await epubModifier.scanEpubTypes(zip, targetFilePath);

      return res.json({
        success: true,
        data: result,
      });
    } catch (error) {
      logger.error('Failed to scan epub:type values', error instanceof Error ? error : undefined);
      return res.status(500).json({
        success: false,
        error: error instanceof Error ? error.message : 'Failed to scan epub:type values',
      });
    }
  },

  ---
  3. Backend: Add route to epub.routes.ts

  Add this line after the other job routes:

  router.get('/job/:jobId/scan-epub-types', authenticate, epubController.scanEpubTypes);
