## Context
Adding token counting and cost estimation to track AI usage costs per request and per tenant. This is critical for the subscription model where customers pay based on usage.

## Current State
- US-2.3.1 complete with GeminiService
- Gemini API client working with rate limiting
- Usage metadata returned from API calls

## Objective
Create a cost tracking service that estimates and logs token usage and costs for all AI operations.

## Technical Requirements

**Create `src/config/pricing.config.ts`:**
```typescript
// Pricing per 1M tokens (as of Dec 2024)
// Source: https://ai.google.dev/pricing
export const aiPricing = {
  'gemini-1.5-flash': {
    input: 0.075,   // $0.075 per 1M input tokens
    output: 0.30,   // $0.30 per 1M output tokens
    cached: 0.01875, // $0.01875 per 1M cached tokens
  },
  'gemini-1.5-pro': {
    input: 1.25,    // $1.25 per 1M input tokens
    output: 5.00,   // $5.00 per 1M output tokens
    cached: 0.3125, // $0.3125 per 1M cached tokens
  },
  'gemini-2.0-flash-lite': {
    input: 0.075,
    output: 0.30,
    cached: 0.01875,
  },
} as const;

export type SupportedModel = keyof typeof aiPricing;

export function getModelPricing(model: string): { input: number; output: number; cached: number } {
  // Normalize model name
  const normalizedModel = model.toLowerCase();
  
  if (normalizedModel.includes('flash-lite') || normalizedModel.includes('2.0-flash')) {
    return aiPricing['gemini-2.0-flash-lite'];
  }
  if (normalizedModel.includes('flash')) {
    return aiPricing['gemini-1.5-flash'];
  }
  if (normalizedModel.includes('pro')) {
    return aiPricing['gemini-1.5-pro'];
  }
  
  // Default to flash pricing
  return aiPricing['gemini-1.5-flash'];
}
```

**Create `src/services/ai/token-counter.service.ts`:**
```typescript
import { getModelPricing } from '../../config/pricing.config.js';

export interface TokenUsage {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
}

export interface CostEstimate {
  inputCost: number;
  outputCost: number;
  totalCost: number;
  currency: 'USD';
}

export interface UsageRecord {
  id: string;
  tenantId: string;
  userId: string;
  model: string;
  operation: string;
  usage: TokenUsage;
  cost: CostEstimate;
  timestamp: Date;
  metadata?: Record<string, unknown>;
}

class TokenCounterService {
  private usageRecords: UsageRecord[] = [];

  /**
   * Estimate tokens for a text string
   * Approximation: ~4 characters per token for English
   */
  estimateTokens(text: string): number {
    if (!text) return 0;
    // More accurate estimation considering whitespace and punctuation
    const words = text.split(/\s+/).filter(w => w.length > 0);
    const avgTokensPerWord = 1.3; // Most words are 1-2 tokens
    return Math.ceil(words.length * avgTokensPerWord);
  }

  /**
   * Calculate cost based on token usage and model
   */
  calculateCost(usage: TokenUsage, model: string): CostEstimate {
    const pricing = getModelPricing(model);
    
    // Convert to cost (pricing is per 1M tokens)
    const inputCost = (usage.promptTokens / 1_000_000) * pricing.input;
    const outputCost = (usage.completionTokens / 1_000_000) * pricing.output;
    
    return {
      inputCost: Math.round(inputCost * 1_000_000) / 1_000_000, // Round to 6 decimal places
      outputCost: Math.round(outputCost * 1_000_000) / 1_000_000,
      totalCost: Math.round((inputCost + outputCost) * 1_000_000) / 1_000_000,
      currency: 'USD',
    };
  }

  /**
   * Record usage for a tenant
   */
  recordUsage(
    tenantId: string,
    userId: string,
    model: string,
    operation: string,
    usage: TokenUsage,
    metadata?: Record<string, unknown>
  ): UsageRecord {
    const cost = this.calculateCost(usage, model);
    
    const record: UsageRecord = {
      id: `usage_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      tenantId,
      userId,
      model,
      operation,
      usage,
      cost,
      timestamp: new Date(),
      metadata,
    };
    
    this.usageRecords.push(record);
    
    // Log for monitoring
    console.log(`[AI Usage] Tenant: ${tenantId}, Op: ${operation}, Tokens: ${usage.totalTokens}, Cost: $${cost.totalCost.toFixed(6)}`);
    
    return record;
  }

  /**
   * Get usage summary for a tenant
   */
  getTenantUsageSummary(
    tenantId: string,
    startDate?: Date,
    endDate?: Date
  ): {
    totalTokens: number;
    totalCost: number;
    requestCount: number;
    byModel: Record<string, { tokens: number; cost: number; requests: number }>;
    byOperation: Record<string, { tokens: number; cost: number; requests: number }>;
  } {
    let records = this.usageRecords.filter(r => r.tenantId === tenantId);
    
    if (startDate) {
      records = records.filter(r => r.timestamp >= startDate);
    }
    if (endDate) {
      records = records.filter(r => r.timestamp <= endDate);
    }
    
    const byModel: Record<string, { tokens: number; cost: number; requests: number }> = {};
    const byOperation: Record<string, { tokens: number; cost: number; requests: number }> = {};
    
    let totalTokens = 0;
    let totalCost = 0;
    
    for (const record of records) {
      totalTokens += record.usage.totalTokens;
      totalCost += record.cost.totalCost;
      
      // Aggregate by model
      if (!byModel[record.model]) {
        byModel[record.model] = { tokens: 0, cost: 0, requests: 0 };
      }
      byModel[record.model].tokens += record.usage.totalTokens;
      byModel[record.model].cost += record.cost.totalCost;
      byModel[record.model].requests += 1;
      
      // Aggregate by operation
      if (!byOperation[record.operation]) {
        byOperation[record.operation] = { tokens: 0, cost: 0, requests: 0 };
      }
      byOperation[record.operation].tokens += record.usage.totalTokens;
      byOperation[record.operation].cost += record.cost.totalCost;
      byOperation[record.operation].requests += 1;
    }
    
    return {
      totalTokens,
      totalCost: Math.round(totalCost * 1_000_000) / 1_000_000,
      requestCount: records.length,
      byModel,
      byOperation,
    };
  }

  /**
   * Get recent usage records for a tenant
   */
  getRecentUsage(tenantId: string, limit = 100): UsageRecord[] {
    return this.usageRecords
      .filter(r => r.tenantId === tenantId)
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, limit);
  }

  /**
   * Estimate cost before making an API call
   */
  estimateCost(promptText: string, model: string, expectedOutputTokens = 1000): CostEstimate {
    const promptTokens = this.estimateTokens(promptText);
    return this.calculateCost(
      { promptTokens, completionTokens: expectedOutputTokens, totalTokens: promptTokens + expectedOutputTokens },
      model
    );
  }

  /**
   * Clear old records (for memory management in development)
   */
  clearOldRecords(olderThan: Date): number {
    const initialCount = this.usageRecords.length;
    this.usageRecords = this.usageRecords.filter(r => r.timestamp >= olderThan);
    return initialCount - this.usageRecords.length;
  }
}

export const tokenCounterService = new TokenCounterService();
```

**Update `src/services/ai/gemini.service.ts` to integrate token counting:**

Add this import at the top:
```typescript
import { tokenCounterService } from './token-counter.service.js';
```

Add a new method to track usage:
```typescript
async generateTextWithTracking(
  prompt: string,
  tenantId: string,
  userId: string,
  operation: string,
  options: GeminiOptions = {}
): Promise<GeminiResponse & { usageRecord?: UsageRecord }> {
  const response = await this.generateText(prompt, options);
  
  let usageRecord;
  if (response.usage) {
    const model = options.model === 'pro' ? 'gemini-1.5-pro' : 'gemini-1.5-flash';
    usageRecord = tokenCounterService.recordUsage(
      tenantId,
      userId,
      model,
      operation,
      response.usage
    );
  }
  
  return { ...response, usageRecord };
}
```

Also import UsageRecord type at the top:
```typescript
import { tokenCounterService, UsageRecord } from './token-counter.service.js';
```

**Add usage endpoints to `src/routes/ai.routes.ts`:**

Add these new endpoints:
```typescript
import { tokenCounterService } from '../services/ai/token-counter.service.js';

// Estimate cost before making a call
router.post('/estimate', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { prompt, model = 'flash', expectedOutputTokens = 1000 } = req.body;
    
    if (!prompt) {
      return res.status(400).json({
        success: false,
        error: { message: 'Prompt is required' },
      });
    }
    
    const modelName = model === 'pro' ? 'gemini-1.5-pro' : 'gemini-1.5-flash';
    const estimate = tokenCounterService.estimateCost(prompt, modelName, expectedOutputTokens);
    const estimatedTokens = tokenCounterService.estimateTokens(prompt);
    
    res.json({
      success: true,
      data: {
        estimatedInputTokens: estimatedTokens,
        estimatedOutputTokens: expectedOutputTokens,
        estimatedTotalTokens: estimatedTokens + expectedOutputTokens,
        estimatedCost: estimate,
        model: modelName,
      },
    });
  } catch (error) {
    next(error);
  }
});

// Get usage summary for the authenticated user's tenant
router.get('/usage', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId || 'default';
    const { startDate, endDate } = req.query;
    
    const summary = tokenCounterService.getTenantUsageSummary(
      tenantId,
      startDate ? new Date(startDate as string) : undefined,
      endDate ? new Date(endDate as string) : undefined
    );
    
    res.json({
      success: true,
      data: summary,
    });
  } catch (error) {
    next(error);
  }
});

// Get recent usage records
router.get('/usage/recent', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId || 'default';
    const limit = parseInt(req.query.limit as string) || 100;
    
    const records = tokenCounterService.getRecentUsage(tenantId, limit);
    
    res.json({
      success: true,
      data: records,
    });
  } catch (error) {
    next(error);
  }
});
```

## Tasks
1. Create src/config/pricing.config.ts with Gemini pricing
2. Create src/services/ai/token-counter.service.ts
3. Update src/services/ai/gemini.service.ts to integrate token counting
4. Add usage endpoints to src/routes/ai.routes.ts
5. Verify server starts without errors
6. Test estimate endpoint: POST /api/v1/ai/estimate

## Acceptance Criteria
- [ ] Pricing config with current Gemini rates
- [ ] Token estimation from text
- [ ] Cost calculation based on model and tokens
- [ ] Usage recording per tenant
- [ ] Usage summary aggregation
- [ ] Estimate endpoint working
- [ ] Usage endpoints returning data