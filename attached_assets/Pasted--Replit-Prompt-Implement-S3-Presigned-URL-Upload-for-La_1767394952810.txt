 Replit Prompt: Implement S3 Presigned URL Upload for Large EPUB Files

  Context

  The current file upload goes through API Gateway which has a 10MB payload limit. We need to implement S3 presigned URL uploads to support larger EPUB files (up to 100MB+). The backend will generate presigned URLs, and the frontend will upload directly to S3.

  Architecture

  Frontend → Request presigned URL → Backend
  Frontend → Upload directly to S3 using presigned URL
  Frontend → Confirm upload to Backend → Backend processes file from S3

  Files to Create/Modify

  1. Create src/config/index.ts - Add S3 config

  Add to the Config interface and config object:

  interface Config {
    // ... existing fields
    s3Bucket: string;
    s3Region: string;
    awsAccessKeyId: string | null;
    awsSecretAccessKey: string | null;
  }

  export const config: Config = {
    // ... existing fields
    s3Bucket: process.env.S3_BUCKET || 'ninja-epub-staging',
    s3Region: process.env.S3_REGION || 'ap-south-1',
    awsAccessKeyId: process.env.AWS_ACCESS_KEY_ID || null,
    awsSecretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || null,
  };

  2. Create src/services/s3.service.ts

  import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
  import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
  import { config } from '../config';
  import { logger } from '../lib/logger';

  const s3Client = new S3Client({
    region: config.s3Region,
    ...(config.awsAccessKeyId && config.awsSecretAccessKey ? {
      credentials: {
        accessKeyId: config.awsAccessKeyId,
        secretAccessKey: config.awsSecretAccessKey,
      }
    } : {}), // Use IAM role if no explicit credentials
  });

  export interface PresignedUploadResult {
    uploadUrl: string;
    fileKey: string;
    expiresIn: number;
  }

  export interface PresignedDownloadResult {
    downloadUrl: string;
    expiresIn: number;
  }

  class S3Service {
    private bucket = config.s3Bucket;

    /**
     * Generate a presigned URL for uploading a file
     */
    async getPresignedUploadUrl(
      tenantId: string,
      fileName: string,
      contentType: string = 'application/epub+zip',
      expiresIn: number = 3600 // 1 hour
    ): Promise<PresignedUploadResult> {
      const timestamp = Date.now();
      const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9._-]/g, '_');
      const fileKey = `uploads/${tenantId}/${timestamp}-${sanitizedFileName}`;

      const command = new PutObjectCommand({
        Bucket: this.bucket,
        Key: fileKey,
        ContentType: contentType,
      });

      const uploadUrl = await getSignedUrl(s3Client, command, { expiresIn });

      logger.info(`Generated presigned upload URL for ${fileKey}`);

      return {
        uploadUrl,
        fileKey,
        expiresIn,
      };
    }

    /**
     * Generate a presigned URL for downloading a file
     */
    async getPresignedDownloadUrl(
      fileKey: string,
      expiresIn: number = 3600
    ): Promise<PresignedDownloadResult> {
      const command = new GetObjectCommand({
        Bucket: this.bucket,
        Key: fileKey,
      });

      const downloadUrl = await getSignedUrl(s3Client, command, { expiresIn });

      return {
        downloadUrl,
        expiresIn,
      };
    }

    /**
     * Get file from S3 as buffer (for processing)
     */
    async getFileBuffer(fileKey: string): Promise<Buffer> {
      const command = new GetObjectCommand({
        Bucket: this.bucket,
        Key: fileKey,
      });

      const response = await s3Client.send(command);
      const stream = response.Body as NodeJS.ReadableStream;

      const chunks: Buffer[] = [];
      for await (const chunk of stream) {
        chunks.push(Buffer.from(chunk));
      }

      return Buffer.concat(chunks);
    }

    /**
     * Delete a file from S3
     */
    async deleteFile(fileKey: string): Promise<void> {
      const command = new DeleteObjectCommand({
        Bucket: this.bucket,
        Key: fileKey,
      });

      await s3Client.send(command);
      logger.info(`Deleted file from S3: ${fileKey}`);
    }

    /**
     * Check if S3 is configured and available
     */
    isConfigured(): boolean {
      return !!this.bucket;
    }
  }

  export const s3Service = new S3Service();

  3. Create src/controllers/upload.controller.ts

  import { Request, Response } from 'express';
  import { s3Service } from '../services/s3.service';
  import prisma from '../lib/prisma';
  import { logger } from '../lib/logger';

  /**
   * Generate presigned URL for file upload
   * POST /api/v1/uploads/presign
   */
  export const getPresignedUploadUrl = async (req: Request, res: Response) => {
    try {
      const { fileName, contentType, fileSize } = req.body;
      const tenantId = req.user?.tenantId;

      if (!tenantId) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      if (!fileName) {
        return res.status(400).json({ success: false, error: 'fileName is required' });
      }

      // Validate file extension
      if (!fileName.toLowerCase().endsWith('.epub')) {
        return res.status(400).json({ success: false, error: 'Only EPUB files are allowed' });
      }

      // Validate file size (max 100MB)
      const maxSize = 100 * 1024 * 1024;
      if (fileSize && fileSize > maxSize) {
        return res.status(400).json({
          success: false,
          error: `File size exceeds maximum allowed (${maxSize / 1024 / 1024}MB)`
        });
      }

      const result = await s3Service.getPresignedUploadUrl(
        tenantId,
        fileName,
        contentType || 'application/epub+zip'
      );

      // Create a pending file record
      const file = await prisma.file.create({
        data: {
          tenantId,
          name: fileName,
          originalName: fileName,
          mimeType: contentType || 'application/epub+zip',
          size: fileSize || 0,
          status: 'PENDING_UPLOAD',
          storagePath: result.fileKey,
          storageType: 'S3',
        },
      });

      res.json({
        success: true,
        data: {
          uploadUrl: result.uploadUrl,
          fileKey: result.fileKey,
          fileId: file.id,
          expiresIn: result.expiresIn,
        },
      });
    } catch (error) {
      logger.error('Failed to generate presigned URL', error instanceof Error ? error : undefined);
      res.status(500).json({ success: false, error: 'Failed to generate upload URL' });
    }
  };

  /**
   * Confirm file upload completed
   * POST /api/v1/uploads/:fileId/confirm
   */
  export const confirmUpload = async (req: Request, res: Response) => {
    try {
      const { fileId } = req.params;
      const tenantId = req.user?.tenantId;

      if (!tenantId) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      const file = await prisma.file.findFirst({
        where: { id: fileId, tenantId },
      });

      if (!file) {
        return res.status(404).json({ success: false, error: 'File not found' });
      }

      if (file.status !== 'PENDING_UPLOAD') {
        return res.status(400).json({ success: false, error: 'File upload already confirmed' });
      }

      // Update file status
      const updatedFile = await prisma.file.update({
        where: { id: fileId },
        data: { status: 'UPLOADED' },
      });

      res.json({
        success: true,
        data: updatedFile,
      });
    } catch (error) {
      logger.error('Failed to confirm upload', error instanceof Error ? error : undefined);
      res.status(500).json({ success: false, error: 'Failed to confirm upload' });
    }
  };

  /**
   * Get presigned download URL for a file
   * GET /api/v1/uploads/:fileId/download
   */
  export const getPresignedDownloadUrl = async (req: Request, res: Response) => {
    try {
      const { fileId } = req.params;
      const tenantId = req.user?.tenantId;

      if (!tenantId) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      const file = await prisma.file.findFirst({
        where: { id: fileId, tenantId, storageType: 'S3' },
      });

      if (!file || !file.storagePath) {
        return res.status(404).json({ success: false, error: 'File not found' });
      }

      const result = await s3Service.getPresignedDownloadUrl(file.storagePath);

      res.json({
        success: true,
        data: {
          downloadUrl: result.downloadUrl,
          fileName: file.originalName,
          expiresIn: result.expiresIn,
        },
      });
    } catch (error) {
      logger.error('Failed to generate download URL', error instanceof Error ? error : undefined);
      res.status(500).json({ success: false, error: 'Failed to generate download URL' });
    }
  };

  4. Create src/routes/upload.routes.ts

  import { Router } from 'express';
  import { authenticate } from '../middleware/auth.middleware';
  import {
    getPresignedUploadUrl,
    confirmUpload,
    getPresignedDownloadUrl
  } from '../controllers/upload.controller';

  const router = Router();

  // All routes require authentication
  router.use(authenticate);

  // Generate presigned URL for upload
  router.post('/presign', getPresignedUploadUrl);

  // Confirm upload completed
  router.post('/:fileId/confirm', confirmUpload);

  // Get presigned URL for download
  router.get('/:fileId/download', getPresignedDownloadUrl);

  export default router;

  5. Update src/routes/index.ts - Add upload routes

  import uploadRoutes from './upload.routes';

  // Add to router registration
  router.use('/uploads', uploadRoutes);

  6. Update Prisma schema if needed

  Add to prisma/schema.prisma File model (if not exists):

  model File {
    // ... existing fields
    storageType  String   @default("LOCAL") // LOCAL, S3
    storagePath  String?  // S3 key or local path
  }

  Run npx prisma migrate dev if schema changes are needed.

  7. Update src/services/epub/epub-audit.service.ts

  Modify runAudit to support S3 files:

  import { s3Service } from '../s3.service';

  // Add method to audit from S3
  async runAuditFromS3(fileKey: string, jobId: string, fileName: string): Promise<EpubAuditResult> {
    const buffer = await s3Service.getFileBuffer(fileKey);
    return this.runAudit(buffer, jobId, fileName);
  }

  Dependencies

  Install AWS SDK:
  npm install @aws-sdk/client-s3 @aws-sdk/s3-request-presigner

  Environment Variables

  Add to ECS task definition:
  - S3_BUCKET: ninja-epub-staging
  - S3_REGION: ap-south-1

  Note: AWS credentials will use the ECS task role (IAM role) - no need for explicit keys.

  IAM Policy for ECS Task Role

  The ECS task execution role needs S3 permissions:
  {
    "Version": "2012-10-17",
    "Statement": [
      {
        "Effect": "Allow",
        "Action": [
          "s3:PutObject",
          "s3:GetObject",
          "s3:DeleteObject"
        ],
        "Resource": "arn:aws:s3:::ninja-epub-staging/*"
      }
    ]
  }

  Testing

  1. Call POST /api/v1/uploads/presign with { fileName: "test.epub" }
  2. Use returned uploadUrl to PUT the file directly to S3
  3. Call POST /api/v1/uploads/:fileId/confirm to confirm upload
  4. Trigger audit job using the fileId