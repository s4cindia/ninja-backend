## Context
Creating API endpoints to create jobs, check job status, list jobs, and cancel jobs. This completes the job queue functionality.

## Current State
- BullMQ queues configured
- Workers ready to process jobs
- QueueService has core methods
- Jobs routes exist but return 501

## Objective
Implement the jobs API endpoints with proper validation and authentication.

## Technical Requirements

**Create `src/controllers/job.controller.ts`:**
```typescript
import { Request, Response, NextFunction } from 'express';
import { prisma } from '../lib/prisma.js';
import { queueService } from '../services/queue.service.js';
import { AppError } from '../utils/app-error.js';
import { ErrorCodes } from '../utils/error-codes.js';
import { JobType } from '../queues/index.js';

export class JobController {
  async create(req: Request, res: Response, next: NextFunction) {
    try {
      if (!req.user) {
        throw AppError.unauthorized('Not authenticated');
      }

      const { type, fileId, productId, priority, options } = req.body;

      const jobId = await queueService.createJob({
        type: type as JobType,
        tenantId: req.user.tenantId,
        userId: req.user.id,
        fileId,
        productId,
        priority,
        options,
      });

      const job = await queueService.getJobStatus(jobId, req.user.tenantId);

      res.status(201).json({
        success: true,
        data: job,
      });
    } catch (error) {
      next(error);
    }
  }

  async list(req: Request, res: Response, next: NextFunction) {
    try {
      if (!req.user) {
        throw AppError.unauthorized('Not authenticated');
      }

      const { 
        page = '1', 
        limit = '20', 
        status, 
        type 
      } = req.query;

      const pageNum = parseInt(page as string, 10);
      const limitNum = parseInt(limit as string, 10);
      const skip = (pageNum - 1) * limitNum;

      const where: any = {
        tenantId: req.user.tenantId,
      };

      if (status) {
        where.status = status;
      }

      if (type) {
        where.type = type;
      }

      const [jobs, total] = await Promise.all([
        prisma.job.findMany({
          where,
          skip,
          take: limitNum,
          orderBy: { createdAt: 'desc' },
          select: {
            id: true,
            type: true,
            status: true,
            progress: true,
            priority: true,
            createdAt: true,
            startedAt: true,
            completedAt: true,
            product: {
              select: {
                id: true,
                title: true,
              },
            },
          },
        }),
        prisma.job.count({ where }),
      ]);

      res.json({
        success: true,
        data: {
          jobs,
          pagination: {
            page: pageNum,
            limit: limitNum,
            total,
            pages: Math.ceil(total / limitNum),
          },
        },
      });
    } catch (error) {
      next(error);
    }
  }

  async get(req: Request, res: Response, next: NextFunction) {
    try {
      if (!req.user) {
        throw AppError.unauthorized('Not authenticated');
      }

      const job = await queueService.getJobStatus(req.params.id, req.user.tenantId);

      res.json({
        success: true,
        data: job,
      });
    } catch (error) {
      next(error);
    }
  }

  async getStatus(req: Request, res: Response, next: NextFunction) {
    try {
      if (!req.user) {
        throw AppError.unauthorized('Not authenticated');
      }

      const job = await prisma.job.findFirst({
        where: {
          id: req.params.id,
          tenantId: req.user.tenantId,
        },
        select: {
          id: true,
          status: true,
          progress: true,
          error: true,
          startedAt: true,
          completedAt: true,
        },
      });

      if (!job) {
        throw AppError.notFound('Job not found', ErrorCodes.JOB_NOT_FOUND);
      }

      res.json({
        success: true,
        data: job,
      });
    } catch (error) {
      next(error);
    }
  }

  async getResults(req: Request, res: Response, next: NextFunction) {
    try {
      if (!req.user) {
        throw AppError.unauthorized('Not authenticated');
      }

      const job = await prisma.job.findFirst({
        where: {
          id: req.params.id,
          tenantId: req.user.tenantId,
        },
        select: {
          id: true,
          type: true,
          status: true,
          output: true,
          completedAt: true,
          validationResults: {
            select: {
              id: true,
              category: true,
              checkType: true,
              passed: true,
              score: true,
              details: true,
              issues: {
                select: {
                  id: true,
                  severity: true,
                  wcagCriteria: true,
                  description: true,
                  location: true,
                  suggestion: true,
                  autoFixable: true,
                },
              },
            },
          },
        },
      });

      if (!job) {
        throw AppError.notFound('Job not found', ErrorCodes.JOB_NOT_FOUND);
      }

      if (job.status !== 'COMPLETED') {
        throw AppError.badRequest(
          'Job results not available. Job status: ' + job.status,
          ErrorCodes.JOB_NOT_FOUND
        );
      }

      res.json({
        success: true,
        data: {
          jobId: job.id,
          type: job.type,
          completedAt: job.completedAt,
          output: job.output,
          validationResults: job.validationResults,
        },
      });
    } catch (error) {
      next(error);
    }
  }

  async cancel(req: Request, res: Response, next: NextFunction) {
    try {
      if (!req.user) {
        throw AppError.unauthorized('Not authenticated');
      }

      await queueService.cancelJob(req.params.id, req.user.tenantId);

      res.json({
        success: true,
        message: 'Job cancelled successfully',
      });
    } catch (error) {
      next(error);
    }
  }

  async getStats(req: Request, res: Response, next: NextFunction) {
    try {
      if (!req.user) {
        throw AppError.unauthorized('Not authenticated');
      }

      const [byStatus, byType, recent] = await Promise.all([
        prisma.job.groupBy({
          by: ['status'],
          where: { tenantId: req.user.tenantId },
          _count: true,
        }),
        prisma.job.groupBy({
          by: ['type'],
          where: { tenantId: req.user.tenantId },
          _count: true,
        }),
        prisma.job.findMany({
          where: { tenantId: req.user.tenantId },
          orderBy: { createdAt: 'desc' },
          take: 5,
          select: {
            id: true,
            type: true,
            status: true,
            createdAt: true,
          },
        }),
      ]);

      res.json({
        success: true,
        data: {
          byStatus: byStatus.reduce((acc, item) => {
            acc[item.status] = item._count;
            return acc;
          }, {} as Record<string, number>),
          byType: byType.reduce((acc, item) => {
            acc[item.type] = item._count;
            return acc;
          }, {} as Record<string, number>),
          recentJobs: recent,
        },
      });
    } catch (error) {
      next(error);
    }
  }
}

export const jobController = new JobController();
```

**Update `src/routes/jobs.routes.ts`:**
```typescript
import { Router } from 'express';
import { authenticate } from '../middleware/auth.middleware.js';
import { validate } from '../middleware/validate.middleware.js';
import { jobController } from '../controllers/job.controller.js';
import { createJobSchema, listJobsSchema } from '../schemas/job.schemas.js';

const router = Router();

// All job routes require authentication
router.use(authenticate);

// GET /api/v1/jobs - List jobs
router.get('/', validate(listJobsSchema), (req, res, next) => 
  jobController.list(req, res, next)
);

// GET /api/v1/jobs/stats - Get job statistics
router.get('/stats', (req, res, next) => 
  jobController.getStats(req, res, next)
);

// POST /api/v1/jobs - Create job
router.post('/', validate(createJobSchema), (req, res, next) => 
  jobController.create(req, res, next)
);

// GET /api/v1/jobs/:id - Get job details
router.get('/:id', (req, res, next) => 
  jobController.get(req, res, next)
);

// GET /api/v1/jobs/:id/status - Get job status (polling endpoint)
router.get('/:id/status', (req, res, next) => 
  jobController.getStatus(req, res, next)
);

// GET /api/v1/jobs/:id/results - Get job results
router.get('/:id/results', (req, res, next) => 
  jobController.getResults(req, res, next)
);

// DELETE /api/v1/jobs/:id - Cancel job
router.delete('/:id', (req, res, next) => 
  jobController.cancel(req, res, next)
);

export default router;
```

**Add to Prisma schema if not present (check first):**

The Job model should have a relation to ValidationResult. Verify this exists:
```prisma
model Job {
  // ... existing fields ...
  validationResults ValidationResult[]
}
```

If you need to update the schema, run:
```bash
npx prisma db push
npx prisma generate
```

## Tasks
1. Create src/controllers/job.controller.ts
2. Update src/routes/jobs.routes.ts with controller methods
3. Verify Prisma schema has Job -> ValidationResult relation
4. Run prisma generate if schema was updated
5. Test all job endpoints work

## Acceptance Criteria
- [ ] POST /api/v1/jobs creates a new job
- [ ] GET /api/v1/jobs lists jobs with pagination
- [ ] GET /api/v1/jobs/stats returns job statistics
- [ ] GET /api/v1/jobs/:id returns job details
- [ ] GET /api/v1/jobs/:id/status returns minimal status info (for polling)
- [ ] GET /api/v1/jobs/:id/results returns job results (only for completed jobs)
- [ ] DELETE /api/v1/jobs/:id cancels a job
- [ ] All endpoints require authentication
- [ ] All endpoints respect tenant isolation