 Step 2: Update the Remediation Plan Builder (Backend)

  Update your remediation plan service to use the new classification:

  // src/services/remediation-plan.service.ts

  import {
    getFixType,
    isAutoFixable,
    isQuickFixable,
    FixType,
    getFixTypeLabel
  } from '../constants/fix-classification';

  interface RemediationTask {
    id: string;
    issueCode: string;
    message: string;
    severity: string;
    location?: string;
    fixType: FixType;
    fixTypeLabel: string;
  }

  interface RemediationPlanStats {
    total: number;
    autoFixable: number;
    quickFixable: number;
    manual: number;
    byFixType: Record<FixType, number>;
  }

  interface RemediationPlan {
    id: string;
    epubId: string;
    jobId: string;
    tasks: RemediationTask[];
    stats: RemediationPlanStats;
    createdAt: string;
  }

  export function buildRemediationPlan(
    jobId: string,
    epubId: string,
    issues: any[]
  ): RemediationPlan {
    // Map issues to tasks with proper classification
    const tasks: RemediationTask[] = issues.map((issue, index) => {
      const fixType = getFixType(issue.code);

      return {
        id: `task-${index}`,
        issueCode: issue.code,
        message: issue.message,
        severity: issue.severity || 'moderate',
        location: issue.location,
        fixType,
        fixTypeLabel: getFixTypeLabel(fixType),
      };
    });

    // Calculate stats
    const stats: RemediationPlanStats = {
      total: tasks.length,
      autoFixable: tasks.filter(t => t.fixType === 'auto').length,
      quickFixable: tasks.filter(t => t.fixType === 'quickfix').length,
      manual: tasks.filter(t => t.fixType === 'manual').length,
      byFixType: {
        auto: tasks.filter(t => t.fixType === 'auto').length,
        quickfix: tasks.filter(t => t.fixType === 'quickfix').length,
        manual: tasks.filter(t => t.fixType === 'manual').length,
      },
    };

    // Validate counts
    const totalCounted = stats.autoFixable + stats.quickFixable + stats.manual;
    if (totalCounted !== stats.total) {
      console.error(`Classification count mismatch: ${totalCounted} !== ${stats.total}`);
    }

    return {
      id: `plan-${Date.now()}`,
      epubId,
      jobId,
      tasks,
      stats,
      createdAt: new Date().toISOString(),
    };
  }

  /**
   * Get only auto-fixable tasks for automatic remediation
   */
  export function getAutoFixableTasks(plan: RemediationPlan): RemediationTask[] {
    return plan.tasks.filter(t => t.fixType === 'auto');
  }

  /**
   * Get tasks that need Quick Fix Panel
   */
  export function getQuickFixTasks(plan: RemediationPlan): RemediationTask[] {
    return plan.tasks.filter(t => t.fixType === 'quickfix');
  }

  /**
   * Get tasks requiring manual intervention
   */
  export function getManualTasks(plan: RemediationPlan): RemediationTask[] {
    return plan.tasks.filter(t => t.fixType === 'manual');
  }
