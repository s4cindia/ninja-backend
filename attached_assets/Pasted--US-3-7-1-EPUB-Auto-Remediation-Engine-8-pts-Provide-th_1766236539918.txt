## US-3.7.1: EPUB Auto-Remediation Engine (8 pts)

Provide this to the agent:
```
Create EPUB auto-remediation engine that actually modifies EPUB files to fix accessibility issues.

**Install dependencies:**
npm install cheerio jszip

**Create file: src/services/epub/epub-modifier.service.ts**

import JSZip from 'jszip';
import * as cheerio from 'cheerio';
import { logger } from '../../lib/logger';

interface ModificationResult {
  success: boolean;
  filePath: string;
  modificationType: string;
  description: string;
  before?: string;
  after?: string;
}

interface EPUBModificationReport {
  totalModifications: number;
  successful: number;
  failed: number;
  modifications: ModificationResult[];
}

class EPUBModifierService {
  /**
   * Load EPUB as JSZip object
   */
  async loadEPUB(buffer: Buffer): Promise<JSZip> {
    return JSZip.loadAsync(buffer);
  }

  /**
   * Save modified EPUB back to buffer
   */
  async saveEPUB(zip: JSZip): Promise<Buffer> {
    return zip.generateAsync({
      type: 'nodebuffer',
      compression: 'DEFLATE',
      compressionOptions: { level: 9 },
    });
  }

  /**
   * Get OPF (Package Document) path and content
   */
  async getOPF(zip: JSZip): Promise<{ path: string; content: string } | null> {
    const containerXml = await zip.file('META-INF/container.xml')?.async('text');
    if (!containerXml) return null;

    const match = containerXml.match(/rootfile[^>]+full-path="([^"]+)"/);
    if (!match) return null;

    const opfPath = match[1];
    const opfContent = await zip.file(opfPath)?.async('text');
    if (!opfContent) return null;

    return { path: opfPath, content: opfContent };
  }

  /**
   * Update OPF content in ZIP
   */
  async updateOPF(zip: JSZip, opfPath: string, content: string): Promise<void> {
    zip.file(opfPath, content);
  }

  /**
   * Add missing language declaration to OPF
   */
  async addLanguage(
    zip: JSZip,
    language: string = 'en'
  ): Promise<ModificationResult> {
    const opf = await this.getOPF(zip);
    if (!opf) {
      return {
        success: false,
        filePath: 'content.opf',
        modificationType: 'add_language',
        description: 'Failed to locate OPF file',
      };
    }

    // Check if language already exists
    if (/<dc:language[^>]*>/i.test(opf.content)) {
      return {
        success: true,
        filePath: opf.path,
        modificationType: 'add_language',
        description: 'Language declaration already exists',
      };
    }

    // Add language after <metadata> or after existing dc elements
    let modified = opf.content;
    const dcPattern = /(<dc:\w+[^>]*>[^<]*<\/dc:\w+>)/i;
    const match = modified.match(dcPattern);

    if (match) {
      const insertAfter = match[0];
      const newElement = `\n    <dc:language>${language}</dc:language>`;
      modified = modified.replace(insertAfter, insertAfter + newElement);
    } else {
      // Insert after <metadata> opening tag
      modified = modified.replace(
        /(<metadata[^>]*>)/i,
        `$1\n    <dc:language>${language}</dc:language>`
      );
    }

    await this.updateOPF(zip, opf.path, modified);

    return {
      success: true,
      filePath: opf.path,
      modificationType: 'add_language',
      description: `Added dc:language element with value "${language}"`,
      before: 'No dc:language element',
      after: `<dc:language>${language}</dc:language>`,
    };
  }

  /**
   * Add accessibility metadata to OPF
   */
  async addAccessibilityMetadata(
    zip: JSZip,
    features: string[] = ['structuralNavigation', 'tableOfContents', 'readingOrder']
  ): Promise<ModificationResult[]> {
    const results: ModificationResult[] = [];
    const opf = await this.getOPF(zip);
    
    if (!opf) {
      return [{
        success: false,
        filePath: 'content.opf',
        modificationType: 'add_accessibility_metadata',
        description: 'Failed to locate OPF file',
      }];
    }

    let modified = opf.content;
    const metadataToAdd: string[] = [];

    // Check and add accessibilityFeature
    for (const feature of features) {
      const featurePattern = new RegExp(`schema:accessibilityFeature[^>]*>${feature}<`, 'i');
      if (!featurePattern.test(modified)) {
        metadataToAdd.push(
          `<meta property="schema:accessibilityFeature">${feature}</meta>`
        );
      }
    }

    // Add accessMode if missing
    if (!/schema:accessMode/i.test(modified)) {
      metadataToAdd.push('<meta property="schema:accessMode">textual</meta>');
    }

    // Add accessModeSufficient if missing
    if (!/schema:accessModeSufficient/i.test(modified)) {
      metadataToAdd.push('<meta property="schema:accessModeSufficient">textual</meta>');
    }

    // Add accessibilityHazard if missing
    if (!/schema:accessibilityHazard/i.test(modified)) {
      metadataToAdd.push('<meta property="schema:accessibilityHazard">none</meta>');
    }

    if (metadataToAdd.length === 0) {
      return [{
        success: true,
        filePath: opf.path,
        modificationType: 'add_accessibility_metadata',
        description: 'Accessibility metadata already present',
      }];
    }

    // Insert before </metadata>
    const insertContent = '\n    ' + metadataToAdd.join('\n    ');
    modified = modified.replace('</metadata>', insertContent + '\n  </metadata>');

    await this.updateOPF(zip, opf.path, modified);

    results.push({
      success: true,
      filePath: opf.path,
      modificationType: 'add_accessibility_metadata',
      description: `Added ${metadataToAdd.length} accessibility metadata elements`,
      after: metadataToAdd.join('\n'),
    });

    return results;
  }

  /**
   * Add accessibility summary to OPF
   */
  async addAccessibilitySummary(
    zip: JSZip,
    summary?: string
  ): Promise<ModificationResult> {
    const opf = await this.getOPF(zip);
    if (!opf) {
      return {
        success: false,
        filePath: 'content.opf',
        modificationType: 'add_accessibility_summary',
        description: 'Failed to locate OPF file',
      };
    }

    if (/schema:accessibilitySummary/i.test(opf.content)) {
      return {
        success: true,
        filePath: opf.path,
        modificationType: 'add_accessibility_summary',
        description: 'Accessibility summary already exists',
      };
    }

    const defaultSummary = summary || 
      'This publication includes structural navigation, a table of contents, and follows a logical reading order.';

    const newElement = `<meta property="schema:accessibilitySummary">${defaultSummary}</meta>`;
    const modified = opf.content.replace(
      '</metadata>',
      `    ${newElement}\n  </metadata>`
    );

    await this.updateOPF(zip, opf.path, modified);

    return {
      success: true,
      filePath: opf.path,
      modificationType: 'add_accessibility_summary',
      description: 'Added accessibility summary',
      after: newElement,
    };
  }

  /**
   * Add lang attribute to HTML documents
   */
  async addHtmlLangAttributes(
    zip: JSZip,
    language: string = 'en'
  ): Promise<ModificationResult[]> {
    const results: ModificationResult[] = [];
    const files = Object.keys(zip.files);

    for (const filePath of files) {
      if (!filePath.match(/\.(html|xhtml|htm)$/i)) continue;

      const content = await zip.file(filePath)?.async('text');
      if (!content) continue;

      // Check if lang already exists
      if (/<html[^>]+lang=/i.test(content)) continue;

      // Add lang attribute to html element
      const modified = content.replace(
        /<html([^>]*)>/i,
        `<html$1 lang="${language}" xml:lang="${language}">`
      );

      if (modified !== content) {
        zip.file(filePath, modified);
        results.push({
          success: true,
          filePath,
          modificationType: 'add_html_lang',
          description: `Added lang="${language}" attribute`,
          before: '<html ...>',
          after: `<html ... lang="${language}" xml:lang="${language}">`,
        });
      }
    }

    if (results.length === 0) {
      results.push({
        success: true,
        filePath: 'all',
        modificationType: 'add_html_lang',
        description: 'All HTML files already have lang attributes',
      });
    }

    return results;
  }

  /**
   * Add alt="" to decorative images (images without alt)
   */
  async addDecorativeAltAttributes(zip: JSZip): Promise<ModificationResult[]> {
    const results: ModificationResult[] = [];
    const files = Object.keys(zip.files);

    for (const filePath of files) {
      if (!filePath.match(/\.(html|xhtml|htm)$/i)) continue;

      const content = await zip.file(filePath)?.async('text');
      if (!content) continue;

      const $ = cheerio.load(content, { xmlMode: true });
      let modified = false;
      let count = 0;

      $('img').each((_, el) => {
        const $el = $(el);
        if (!$el.attr('alt')) {
          $el.attr('alt', '');
          $el.attr('role', 'presentation');
          modified = true;
          count++;
        }
      });

      if (modified) {
        zip.file(filePath, $.html());
        results.push({
          success: true,
          filePath,
          modificationType: 'add_decorative_alt',
          description: `Marked ${count} image(s) as decorative with alt=""`,
        });
      }
    }

    if (results.length === 0) {
      results.push({
        success: true,
        filePath: 'all',
        modificationType: 'add_decorative_alt',
        description: 'All images already have alt attributes',
      });
    }

    return results;
  }

  /**
   * Add table headers to simple tables
   */
  async addTableHeaders(zip: JSZip): Promise<ModificationResult[]> {
    const results: ModificationResult[] = [];
    const files = Object.keys(zip.files);

    for (const filePath of files) {
      if (!filePath.match(/\.(html|xhtml|htm)$/i)) continue;

      const content = await zip.file(filePath)?.async('text');
      if (!content) continue;

      const $ = cheerio.load(content, { xmlMode: true });
      let modified = false;
      let count = 0;

      $('table').each((_, table) => {
        const $table = $(table);
        
        // Skip if already has th elements
        if ($table.find('th').length > 0) return;

        // Convert first row td to th
        const $firstRow = $table.find('tr').first();
        const $cells = $firstRow.find('td');
        
        if ($cells.length > 0) {
          $cells.each((_, cell) => {
            const $cell = $(cell);
            const content = $cell.html();
            $cell.replaceWith(`<th scope="col">${content}</th>`);
          });
          modified = true;
          count++;
        }
      });

      if (modified) {
        zip.file(filePath, $.html());
        results.push({
          success: true,
          filePath,
          modificationType: 'add_table_headers',
          description: `Added headers to ${count} table(s)`,
        });
      }
    }

    if (results.length === 0) {
      results.push({
        success: true,
        filePath: 'all',
        modificationType: 'add_table_headers',
        description: 'All tables already have headers',
      });
    }

    return results;
  }
}

export const epubModifier = new EPUBModifierService();

**Create file: src/services/epub/auto-remediation.service.ts**

import { epubModifier } from './epub-modifier.service';
import { remediationService } from './remediation.service';
import { logger } from '../../lib/logger';
import prisma from '../../lib/prisma';
import JSZip from 'jszip';

interface AutoRemediationResult {
  jobId: string;
  originalFileName: string;
  remediatedFileName: string;
  totalIssuesFixed: number;
  totalIssuesFailed: number;
  modifications: {
    issueCode: string;
    taskId: string;
    success: boolean;
    description: string;
    before?: string;
    after?: string;
  }[];
  remediatedBuffer: Buffer;
  startedAt: Date;
  completedAt: Date;
}

// Map issue codes to remediation functions
type RemediationFunction = (zip: JSZip, options?: Record<string, unknown>) => Promise<{
  success: boolean;
  description: string;
  before?: string;
  after?: string;
}[]>;

class AutoRemediationService {
  private remediationHandlers: Record<string, RemediationFunction> = {
    'EPUB-META-001': async (zip) => {
      const result = await epubModifier.addLanguage(zip);
      return [result];
    },
    'EPUB-META-002': async (zip) => {
      return epubModifier.addAccessibilityMetadata(zip);
    },
    'EPUB-META-003': async (zip) => {
      const result = await epubModifier.addAccessibilitySummary(zip);
      return [result];
    },
    'EPUB-META-004': async (zip) => {
      // Access modes are added as part of EPUB-META-002
      return epubModifier.addAccessibilityMetadata(zip);
    },
    'EPUB-SEM-001': async (zip) => {
      return epubModifier.addHtmlLangAttributes(zip);
    },
    'EPUB-IMG-001': async (zip) => {
      return epubModifier.addDecorativeAltAttributes(zip);
    },
    'EPUB-STRUCT-002': async (zip) => {
      return epubModifier.addTableHeaders(zip);
    },
  };

  /**
   * Run auto-remediation on an EPUB file
   */
  async runAutoRemediation(
    epubBuffer: Buffer,
    jobId: string,
    fileName: string
  ): Promise<AutoRemediationResult> {
    const startedAt = new Date();
    const modifications: AutoRemediationResult['modifications'] = [];
    let totalFixed = 0;
    let totalFailed = 0;

    try {
      // Load EPUB
      const zip = await epubModifier.loadEPUB(epubBuffer);

      // Get remediation plan
      const plan = await remediationService.getRemediationPlan(jobId);
      if (!plan) {
        throw new Error('No remediation plan found for this job');
      }

      // Process auto-fixable tasks
      const autoTasks = plan.tasks.filter(
        t => t.type === 'auto' && t.status === 'pending'
      );

      for (const task of autoTasks) {
        const handler = this.remediationHandlers[task.issueCode];
        
        if (!handler) {
          modifications.push({
            issueCode: task.issueCode,
            taskId: task.id,
            success: false,
            description: `No auto-fix handler for ${task.issueCode}`,
          });
          totalFailed++;
          continue;
        }

        try {
          const results = await handler(zip);
          
          for (const result of results) {
            if (result.success) {
              totalFixed++;
              
              // Update task status
              await remediationService.updateTaskStatus(
                jobId,
                task.id,
                'completed',
                result.description,
                'auto-remediation'
              );
            } else {
              totalFailed++;
            }

            modifications.push({
              issueCode: task.issueCode,
              taskId: task.id,
              success: result.success,
              description: result.description,
              before: result.before,
              after: result.after,
            });
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Unknown error';
          modifications.push({
            issueCode: task.issueCode,
            taskId: task.id,
            success: false,
            description: `Fix failed: ${message}`,
          });
          totalFailed++;

          // Update task status to failed
          await remediationService.updateTaskStatus(
            jobId,
            task.id,
            'failed',
            message,
            'auto-remediation'
          );
        }
      }

      // Generate remediated EPUB
      const remediatedBuffer = await epubModifier.saveEPUB(zip);
      const remediatedFileName = fileName.replace(/\.epub$/i, '_remediated.epub');

      const completedAt = new Date();

      // Store result
      const result: AutoRemediationResult = {
        jobId,
        originalFileName: fileName,
        remediatedFileName,
        totalIssuesFixed: totalFixed,
        totalIssuesFailed: totalFailed,
        modifications,
        remediatedBuffer,
        startedAt,
        completedAt,
      };

      // Save result metadata (without buffer) to database
      await prisma.job.update({
        where: { id: jobId },
        data: {
          output: {
            ...((await prisma.job.findUnique({ where: { id: jobId } }))?.output as Record<string, unknown> || {}),
            autoRemediation: {
              ...result,
              remediatedBuffer: undefined, // Don't store buffer in DB
              hasRemediatedFile: true,
            },
          },
        },
      });

      logger.info(`Auto-remediation complete for ${jobId}: ${totalFixed} fixed, ${totalFailed} failed`);

      return result;
    } catch (error) {
      logger.error('Auto-remediation failed', error instanceof Error ? error : undefined);
      throw error;
    }
  }

  /**
   * Get list of supported auto-fix issue codes
   */
  getSupportedIssueCodes(): string[] {
    return Object.keys(this.remediationHandlers);
  }

  /**
   * Check if an issue code is auto-fixable
   */
  isAutoFixable(issueCode: string): boolean {
    return issueCode in this.remediationHandlers;
  }
}

export const autoRemediationService = new AutoRemediationService();

**Update src/controllers/epub.controller.ts - Add auto-remediation endpoint:**

Add import at top:
import { autoRemediationService } from '../services/epub/auto-remediation.service';

Add method to epubController:

/**
 * Run auto-remediation on EPUB
 */
async runAutoRemediation(req: AuthenticatedRequest, res: Response) {
  try {
    const { jobId } = req.params;
    const tenantId = req.user?.tenantId;

    if (!tenantId) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required',
      });
    }

    // Get job and verify ownership
    const job = await prisma.job.findFirst({
      where: { id: jobId, tenantId },
    });

    if (!job) {
      return res.status(404).json({
        success: false,
        error: 'Job not found',
      });
    }

    // Get EPUB file from S3 or storage
    const fileKey = `uploads/${jobId}/${job.input?.fileName || 'upload.epub'}`;
    const fileData = await s3Service.getObject(fileKey);

    if (!fileData) {
      return res.status(404).json({
        success: false,
        error: 'EPUB file not found',
      });
    }

    // Run auto-remediation
    const result = await autoRemediationService.runAutoRemediation(
      fileData.buffer,
      jobId,
      job.input?.fileName || 'upload.epub'
    );

    // Store remediated file
    const remediatedKey = `remediated/${jobId}/${result.remediatedFileName}`;
    await s3Service.uploadFile(
      remediatedKey,
      result.remediatedBuffer,
      'application/epub+zip'
    );

    return res.json({
      success: true,
      data: {
        jobId: result.jobId,
        originalFileName: result.originalFileName,
        remediatedFileName: result.remediatedFileName,
        totalIssuesFixed: result.totalIssuesFixed,
        totalIssuesFailed: result.totalIssuesFailed,
        modifications: result.modifications,
        downloadUrl: `/api/v1/epub/job/${jobId}/download-remediated`,
        startedAt: result.startedAt,
        completedAt: result.completedAt,
      },
    });
  } catch (error) {
    logger.error('Auto-remediation failed', error instanceof Error ? error : undefined);
    return res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Auto-remediation failed',
    });
  }
},

/**
 * Get supported auto-fix issue codes
 */
async getSupportedFixes(req: AuthenticatedRequest, res: Response) {
  try {
    const codes = autoRemediationService.getSupportedIssueCodes();

    return res.json({
      success: true,
      data: {
        supportedCodes: codes,
        descriptions: {
          'EPUB-META-001': 'Add missing language declaration',
          'EPUB-META-002': 'Add accessibility feature metadata',
          'EPUB-META-003': 'Add accessibility summary',
          'EPUB-META-004': 'Add access mode metadata',
          'EPUB-SEM-001': 'Add lang attribute to HTML elements',
          'EPUB-IMG-001': 'Mark images without alt as decorative',
          'EPUB-STRUCT-002': 'Add headers to simple tables',
        },
      },
    });
  } catch (error) {
    logger.error('Failed to get supported fixes', error instanceof Error ? error : undefined);
    return res.status(500).json({
      success: false,
      error: 'Failed to get supported fixes',
    });
  }
},

**Update src/routes/epub.routes.ts - Add routes:**

// Auto-remediation routes
router.post('/job/:jobId/auto-remediate', epubController.runAutoRemediation);
router.get('/supported-fixes', epubController.getSupportedFixes);

**Acceptance Criteria:**
- [ ] Load and parse EPUB files with JSZip
- [ ] Add missing dc:language to OPF
- [ ] Add accessibility metadata (accessibilityFeature, accessMode, accessibilityHazard)
- [ ] Add accessibility summary
- [ ] Add lang attribute to HTML documents
- [ ] Mark images without alt as decorative (alt="")
- [ ] Add headers to simple tables
- [ ] Save modified EPUB
- [ ] Track modifications with before/after
- [ ] Update remediation task statuses
- [ ] Store remediated file for download
- [ ] API endpoints for auto-remediation and supported fixes