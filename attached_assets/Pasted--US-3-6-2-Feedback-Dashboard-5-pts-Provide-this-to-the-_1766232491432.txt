## US-3.6.2: Feedback Dashboard (5 pts)

Provide this to the agent:
```
Create feedback dashboard service with statistics and analytics for the feedback collection.

**Update src/services/feedback/feedback.service.ts - Add statistics methods:**

Add these interfaces after the existing ones:

interface FeedbackStats {
  total: number;
  byType: Record<string, number>;
  byStatus: Record<string, number>;
  byRating: Record<string, number>;
  averageRating: number;
  recentCount: number;
  responseRate: number;
  averageResponseTimeHours: number | null;
}

interface FeedbackTrend {
  date: string;
  count: number;
  averageRating: number;
}

interface TopIssue {
  type: string;
  count: number;
  averageRating: number;
  unresolvedCount: number;
}

Add these methods to the FeedbackService class:

/**
 * Get feedback statistics
 */
async getStats(tenantId?: string): Promise<FeedbackStats> {
  const where = tenantId ? { tenantId } : {};

  const allFeedback = await prisma.feedback.findMany({ where });

  const sevenDaysAgo = new Date();
  sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

  const byType: Record<string, number> = {};
  const byStatus: Record<string, number> = {};
  const byRating: Record<string, number> = { '1': 0, '2': 0, '3': 0, '4': 0, '5': 0 };
  
  let ratingSum = 0;
  let ratingCount = 0;
  let recentCount = 0;
  let respondedCount = 0;
  let totalResponseTimeMs = 0;
  let responseTimeCount = 0;

  for (const feedback of allFeedback) {
    // By type
    byType[feedback.type] = (byType[feedback.type] || 0) + 1;

    // By status
    byStatus[feedback.status] = (byStatus[feedback.status] || 0) + 1;

    // By rating
    if (feedback.rating) {
      byRating[String(feedback.rating)] = (byRating[String(feedback.rating)] || 0) + 1;
      ratingSum += feedback.rating;
      ratingCount++;
    }

    // Recent (last 7 days)
    if (feedback.createdAt >= sevenDaysAgo) {
      recentCount++;
    }

    // Response metrics
    if (feedback.respondedAt) {
      respondedCount++;
      const responseTime = feedback.respondedAt.getTime() - feedback.createdAt.getTime();
      totalResponseTimeMs += responseTime;
      responseTimeCount++;
    }
  }

  const total = allFeedback.length;
  const responseRate = total > 0 ? Math.round((respondedCount / total) * 100) : 0;
  const averageResponseTimeHours = responseTimeCount > 0
    ? Math.round((totalResponseTimeMs / responseTimeCount) / (1000 * 60 * 60) * 10) / 10
    : null;

  return {
    total,
    byType,
    byStatus,
    byRating,
    averageRating: ratingCount > 0 ? Math.round((ratingSum / ratingCount) * 10) / 10 : 0,
    recentCount,
    responseRate,
    averageResponseTimeHours,
  };
}

/**
 * Get feedback trends over time
 */
async getTrends(
  tenantId?: string,
  days: number = 30
): Promise<FeedbackTrend[]> {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);
  startDate.setHours(0, 0, 0, 0);

  const where: Record<string, unknown> = {
    createdAt: { gte: startDate },
  };
  if (tenantId) where.tenantId = tenantId;

  const feedback = await prisma.feedback.findMany({
    where,
    orderBy: { createdAt: 'asc' },
  });

  // Group by date
  const trendMap: Record<string, { count: number; ratingSum: number; ratingCount: number }> = {};

  for (const fb of feedback) {
    const dateKey = fb.createdAt.toISOString().split('T')[0];
    
    if (!trendMap[dateKey]) {
      trendMap[dateKey] = { count: 0, ratingSum: 0, ratingCount: 0 };
    }
    
    trendMap[dateKey].count++;
    if (fb.rating) {
      trendMap[dateKey].ratingSum += fb.rating;
      trendMap[dateKey].ratingCount++;
    }
  }

  // Fill in missing dates
  const trends: FeedbackTrend[] = [];
  const currentDate = new Date(startDate);
  const endDate = new Date();

  while (currentDate <= endDate) {
    const dateKey = currentDate.toISOString().split('T')[0];
    const data = trendMap[dateKey];

    trends.push({
      date: dateKey,
      count: data?.count || 0,
      averageRating: data?.ratingCount
        ? Math.round((data.ratingSum / data.ratingCount) * 10) / 10
        : 0,
    });

    currentDate.setDate(currentDate.getDate() + 1);
  }

  return trends;
}

/**
 * Get top issues by feedback volume
 */
async getTopIssues(
  tenantId?: string,
  limit: number = 10
): Promise<TopIssue[]> {
  const where = tenantId ? { tenantId } : {};

  const feedback = await prisma.feedback.findMany({ where });

  const issueMap: Record<string, {
    count: number;
    ratingSum: number;
    ratingCount: number;
    unresolvedCount: number;
  }> = {};

  for (const fb of feedback) {
    const key = fb.type;
    
    if (!issueMap[key]) {
      issueMap[key] = { count: 0, ratingSum: 0, ratingCount: 0, unresolvedCount: 0 };
    }

    issueMap[key].count++;
    
    if (fb.rating) {
      issueMap[key].ratingSum += fb.rating;
      issueMap[key].ratingCount++;
    }

    if (fb.status !== 'RESOLVED' && fb.status !== 'DISMISSED') {
      issueMap[key].unresolvedCount++;
    }
  }

  const topIssues: TopIssue[] = Object.entries(issueMap)
    .map(([type, data]) => ({
      type,
      count: data.count,
      averageRating: data.ratingCount
        ? Math.round((data.ratingSum / data.ratingCount) * 10) / 10
        : 0,
      unresolvedCount: data.unresolvedCount,
    }))
    .sort((a, b) => b.count - a.count)
    .slice(0, limit);

  return topIssues;
}

/**
 * Get recent feedback requiring attention
 */
async getRequiringAttention(
  tenantId?: string,
  limit: number = 10
): Promise<PrismaFeedback[]> {
  const where: Record<string, unknown> = {
    status: { in: ['NEW', 'REVIEWED'] },
  };
  if (tenantId) where.tenantId = tenantId;

  return prisma.feedback.findMany({
    where,
    orderBy: [
      { rating: 'asc' },  // Low ratings first (more urgent)
      { createdAt: 'asc' }, // Oldest first
    ],
    take: limit,
  });
}

**Update src/controllers/feedback.controller.ts - Add dashboard endpoints:**

Add these methods to feedbackController:

/**
 * Get feedback statistics
 */
async getStats(req: AuthenticatedRequest, res: Response) {
  try {
    const tenantId = req.user?.tenantId;
    const stats = await feedbackService.getStats(tenantId);

    return res.json({
      success: true,
      data: stats,
    });
  } catch (error) {
    logger.error('Failed to get feedback stats', error instanceof Error ? error : undefined);
    return res.status(500).json({
      success: false,
      error: 'Failed to get statistics',
    });
  }
},

/**
 * Get feedback trends
 */
async getTrends(req: AuthenticatedRequest, res: Response) {
  try {
    const tenantId = req.user?.tenantId;
    const days = Number(req.query.days) || 30;

    if (days < 1 || days > 365) {
      return res.status(400).json({
        success: false,
        error: 'Days must be between 1 and 365',
      });
    }

    const trends = await feedbackService.getTrends(tenantId, days);

    return res.json({
      success: true,
      data: trends,
    });
  } catch (error) {
    logger.error('Failed to get feedback trends', error instanceof Error ? error : undefined);
    return res.status(500).json({
      success: false,
      error: 'Failed to get trends',
    });
  }
},

/**
 * Get top issues
 */
async getTopIssues(req: AuthenticatedRequest, res: Response) {
  try {
    const tenantId = req.user?.tenantId;
    const limit = Number(req.query.limit) || 10;

    const topIssues = await feedbackService.getTopIssues(tenantId, limit);

    return res.json({
      success: true,
      data: topIssues,
    });
  } catch (error) {
    logger.error('Failed to get top issues', error instanceof Error ? error : undefined);
    return res.status(500).json({
      success: false,
      error: 'Failed to get top issues',
    });
  }
},

/**
 * Get feedback requiring attention
 */
async getRequiringAttention(req: AuthenticatedRequest, res: Response) {
  try {
    const tenantId = req.user?.tenantId;
    const limit = Number(req.query.limit) || 10;

    const feedback = await feedbackService.getRequiringAttention(tenantId, limit);

    return res.json({
      success: true,
      data: feedback,
    });
  } catch (error) {
    logger.error('Failed to get feedback requiring attention', error instanceof Error ? error : undefined);
    return res.status(500).json({
      success: false,
      error: 'Failed to get feedback requiring attention',
    });
  }
},

**Update src/routes/feedback.routes.ts - Add dashboard routes:**

Add these routes BEFORE the /:id route to avoid conflicts:

// Dashboard routes
router.get('/dashboard/stats', feedbackController.getStats);
router.get('/dashboard/trends', feedbackController.getTrends);
router.get('/dashboard/top-issues', feedbackController.getTopIssues);
router.get('/dashboard/requiring-attention', feedbackController.getRequiringAttention);

**Acceptance Criteria:**
- [ ] Get feedback statistics (total, by type, by status, by rating, averages)
- [ ] Get feedback trends over time (daily counts and ratings)
- [ ] Get top issues by volume
- [ ] Get feedback requiring attention (new + low ratings)
- [ ] Response rate and average response time metrics
- [ ] Filter all dashboard data by tenant