 Prompt 35A: Backend - Fix epub:type Apply to All Files + Task Status Update

  Problem

  1. The apply-fix only modifies wasteland-content.xhtml but toc and landmarks are in wasteland-nav.xhtml
  2. Task status is not being updated after successful fix (taskUpdated: false)

  Solution

  ---
  File: src/services/epub/epub-modifier.service.ts

  Add this new method to the EPUBModifierService class:

  async addAriaRolesToEpubTypes(
    zip: JSZip,
    epubTypesToFix: Array<{ epubType: string; role: string }>
  ): Promise<ModificationResult[]> {
    const results: ModificationResult[] = [];

    const xhtmlFiles = Object.keys(zip.files).filter(path =>
      /\.(xhtml|html|htm)$/i.test(path) && !zip.files[path].dir
    );

    console.log(`Adding ARIA roles to ${epubTypesToFix.length} epub:types across ${xhtmlFiles.length} files`);

    for (const filePath of xhtmlFiles) {
      try {
        let content = await zip.file(filePath)?.async('text');
        if (!content) continue;

        const $ = cheerio.load(content, { xmlMode: true, decodeEntities: false });
        let fileModified = false;

        for (const { epubType, role } of epubTypesToFix) {
          $('*').filter((_, el) => {
            const attr = $(el).attr('epub:type');
            if (!attr) return false;
            const types = attr.split(/\s+/);
            return types.includes(epubType) && !$(el).attr('role');
          }).each((_, elem) => {
            const tagName = elem.tagName || 'element';
            const beforeSnippet = `<${tagName} epub:type="${$(elem).attr('epub:type')}">`;

            $(elem).attr('role', role);
            fileModified = true;

            results.push({
              success: true,
              filePath,
              modificationType: 'add_role',
              description: `Added role="${role}" to element with epub:type="${epubType}"`,
              before: beforeSnippet,
              after: `<${tagName} epub:type="${$(elem).attr('epub:type')}" role="${role}">`,
            });
          });
        }

        if (fileModified) {
          zip.file(filePath, $.xml());
          console.log(`Modified ${filePath}`);
        }
      } catch (err) {
        console.error(`Error processing ${filePath}:`, err);
        results.push({
          success: false,
          filePath,
          modificationType: 'add_role',
          description: `Error: ${err instanceof Error ? err.message : 'Unknown error'}`,
        });
      }
    }

    console.log(`Completed: ${results.filter(r => r.success).length} successful, ${results.filter(r => !r.success).length} failed`);
    return results;
  }

  ---
  File: src/controllers/epub.controller.ts

  Find the applyQuickFix or applySpecificFix method and update it to handle EPUB-SEM-003 and update task status:

  async applyQuickFix(req: AuthenticatedRequest, res: Response) {
    try {
      const { jobId } = req.params;
      const { fixCode, taskId, options } = req.body;
      const tenantId = req.user?.tenantId;

      console.log('applyQuickFix called:', { jobId, fixCode, taskId, options });

      if (!tenantId) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      if (!fixCode) {
        return res.status(400).json({ success: false, error: 'fixCode is required' });
      }

      const job = await prisma.job.findFirst({ where: { id: jobId, tenantId } });
      if (!job) {
        return res.status(404).json({ success: false, error: 'Job not found' });
      }

      const input = job.input as { fileName?: string };
      const originalFileName = input?.fileName || 'upload.epub';
      const remediatedFileName = originalFileName.replace(/\.epub$/i, '_remediated.epub');

      // Try remediated file first, fall back to original
      let epubBuffer = await fileStorageService.getRemediatedFile(jobId, remediatedFileName);
      if (!epubBuffer) {
        epubBuffer = await fileStorageService.getFile(jobId, originalFileName);
      }

      if (!epubBuffer) {
        return res.status(404).json({ success: false, error: 'EPUB file not found' });
      }

      const zip = await epubModifier.loadEPUB(epubBuffer);
      let results: ModificationResult[] = [];

      switch (fixCode) {
        case 'EPUB-SEM-003':
        case 'EPUB-TYPE-HAS-MATCHING-ROLE': {
          const epubTypesToFix: Array<{ epubType: string; role: string }> = [];

          // Handle array of epub:types (batch fix)
          if (options?.epubTypes && Array.isArray(options.epubTypes)) {
            epubTypesToFix.push(...options.epubTypes);
          }
          // Handle single epub:type
          else if (options?.epubType && options?.role) {
            epubTypesToFix.push({
              epubType: options.epubType,
              role: options.role,
            });
          }

          if (epubTypesToFix.length === 0) {
            return res.status(400).json({
              success: false,
              error: 'No epub:types specified to fix'
            });
          }

          results = await epubModifier.addAriaRolesToEpubTypes(zip, epubTypesToFix);
          break;
        }

        // ... keep existing cases for other fix codes ...

        default:
          return res.status(400).json({ success: false, error: `Unknown fix code: ${fixCode}` });
      }

      // Save modified EPUB
      const modifiedBuffer = await epubModifier.saveEPUB(zip);
      await fileStorageService.saveRemediatedFile(jobId, remediatedFileName, modifiedBuffer);

      // Calculate success
      const successCount = results.filter(r => r.success).length;
      const failCount = results.filter(r => !r.success).length;

      // Update task status if taskId provided and at least one fix succeeded
      let taskUpdated = false;
      if (taskId && successCount > 0) {
        try {
          await remediationService.updateTaskStatus(
            jobId,
            taskId,
            'completed',
            `Applied ${successCount} ARIA role fixes via Quick Fix Panel`,
            req.user?.email || 'system'
          );
          taskUpdated = true;
          console.log(`Task ${taskId} marked as completed`);
        } catch (err) {
          console.error('Failed to update task status:', err);
        }
      }

      return res.json({
        success: successCount > 0,
        data: {
          success: failCount === 0,
          successCount,
          failCount,
          modifiedFiles: [...new Set(results.filter(r => r.success).map(r => r.filePath))],
          results,
          taskUpdated,
          downloadUrl: `/api/v1/epub/job/${jobId}/download-remediated`,
        },
      });
    } catch (error) {
      console.error('applyQuickFix error:', error);
      return res.status(500).json({
        success: false,
        error: error instanceof Error ? error.message : 'Failed to apply fix',
      });
    }
  },

  ---
  File: src/routes/epub.routes.ts

  Make sure this route exists (it might already as apply-fix):

  router.post('/job/:jobId/apply-quick-fix', authenticate, epubController.applyQuickFix);
  // OR if using existing route:
  router.post('/job/:jobId/apply-fix', authenticate, epubController.applyQuickFix);
