 Part 3: Replace addAriaLandmarks method (conservative, single main)

    async addAriaLandmarks(zip: JSZip): Promise<ModificationResult[]> {
      const results: ModificationResult[] = [];
      const files = Object.keys(zip.files)
        .filter(f => /\.(html|xhtml|htm)$/i.test(f) && !zip.files[f].dir)
        .sort(); // Sort for consistent ordering

      // Track if we've added a main landmark anywhere
      let mainLandmarkExists = false;

      // First pass: check if any file already has role="main"
      for (const filePath of files) {
        const content = await zip.file(filePath)?.async('text');
        if (content && /role\s*=\s*["']main["']/i.test(content)) {
          mainLandmarkExists = true;
          break;
        }
      }

      // Second pass: add main landmark to first suitable file if needed
      for (const filePath of files) {
        let content = await zip.file(filePath)?.async('text');
        if (!content) continue;

        let modified = false;
        const changes: string[] = [];

        // Only add ONE main landmark across entire EPUB
        if (!mainLandmarkExists) {
          // Look for elements that can receive role="main"
          const candidates = [
            { pattern: /(<main)(\s[^>]*>|>)/i, name: 'main' },
            { pattern: /(<section)(\s[^>]*>|>)/i, name: 'section' },
            { pattern: /(<article)(\s[^>]*>|>)/i, name: 'article' },
          ];

          for (const { pattern, name } of candidates) {
            const match = content.match(pattern);
            if (match) {
              const [fullMatch, tagStart, rest] = match;

              // Check if this element already has a role
              if (/\brole\s*=/i.test(fullMatch)) {
                continue; // Skip, already has role
              }

              // Add role="main" after tag name
              const newTag = `${tagStart} role="main"${rest}`;
              content = content.replace(fullMatch, newTag);
              changes.push(`Added role="main" to <${name}>`);
              modified = true;
              mainLandmarkExists = true;
              break;
            }
          }
        }

        if (modified) {
          zip.file(filePath, content);
          results.push({
            success: true,
            filePath,
            modificationType: 'add_aria_landmarks',
            description: changes.join(', '),
          });
        }
      }

      if (results.length === 0) {
        results.push({
          success: true,
          filePath: 'all',
          modificationType: 'add_aria_landmarks',
          description: 'ARIA landmarks already present or not applicable',
        });
      }

      return results;
    }
