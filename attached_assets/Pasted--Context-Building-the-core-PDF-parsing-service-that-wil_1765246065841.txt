## Context
Building the core PDF parsing service that will be the foundation for accessibility validation. This service handles PDF loading, metadata extraction, and provides access to document structure.

## Current State
- US-2.3.1-2.3.3 complete with AI services
- Need PDF parsing capabilities for accessibility analysis
- Job queue ready to process PDF files

## Objective
Create a PDF parsing service using pdf-lib and pdfjs-dist that extracts document structure, metadata, and provides foundation for accessibility checks.

## Technical Requirements

**Install PDF libraries:**
```bash
npm install pdf-lib pdfjs-dist
npm install --save-dev @types/pdfjs-dist
```

**Create `src/config/pdf.config.ts`:**
```typescript
export const pdfConfig = {
  maxFileSizeMB: 100,
  maxPages: 1000,
  supportedVersions: ['1.0', '1.1', '1.2', '1.3', '1.4', '1.5', '1.6', '1.7', '2.0'],
  workerSrc: 'pdfjs-dist/build/pdf.worker.mjs',
  timeout: 120000, // 2 minutes for large PDFs
  chunkSize: 10, // Process pages in chunks
};
```

**Create `src/services/pdf/pdf-parser.service.ts`:**
```typescript
import { PDFDocument, PDFName, PDFDict, PDFArray, PDFString } from 'pdf-lib';
import * as pdfjsLib from 'pdfjs-dist';
import fs from 'fs/promises';
import path from 'path';
import { pdfConfig } from '../../config/pdf.config.js';
import { AppError } from '../../utils/app-error.js';

// Configure PDF.js worker
const pdfjsWorkerPath = path.join(
  process.cwd(),
  'node_modules',
  'pdfjs-dist',
  'build',
  'pdf.worker.mjs'
);

// Set worker source
pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorkerPath;

export interface PDFMetadata {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string[];
  creator?: string;
  producer?: string;
  creationDate?: Date;
  modificationDate?: Date;
  language?: string;
  pdfVersion: string;
  isEncrypted: boolean;
  isLinearized: boolean;
  isTagged: boolean;
  hasOutline: boolean;
  hasAcroForm: boolean;
  hasXFA: boolean;
}

export interface PDFPageInfo {
  pageNumber: number;
  width: number;
  height: number;
  rotation: number;
  hasAnnotations: boolean;
  annotationCount: number;
}

export interface PDFStructure {
  pageCount: number;
  pages: PDFPageInfo[];
  metadata: PDFMetadata;
  outline?: PDFOutlineItem[];
  permissions?: PDFPermissions;
}

export interface PDFOutlineItem {
  title: string;
  destination?: number; // page number
  children?: PDFOutlineItem[];
}

export interface PDFPermissions {
  canPrint: boolean;
  canModify: boolean;
  canCopy: boolean;
  canAnnotate: boolean;
  canFillForms: boolean;
  canExtract: boolean;
  canAssemble: boolean;
  canPrintHighQuality: boolean;
}

export interface ParsedPDF {
  filePath: string;
  fileSize: number;
  structure: PDFStructure;
  pdfLibDoc: PDFDocument;
  pdfjsDoc: pdfjsLib.PDFDocumentProxy;
}

class PDFParserService {
  /**
   * Parse a PDF file and extract structure information
   */
  async parse(filePath: string): Promise<ParsedPDF> {
    // Validate file exists
    const stats = await fs.stat(filePath).catch(() => null);
    if (!stats) {
      throw AppError.notFound('PDF file not found');
    }

    // Check file size
    const fileSizeMB = stats.size / (1024 * 1024);
    if (fileSizeMB > pdfConfig.maxFileSizeMB) {
      throw AppError.badRequest(`PDF file exceeds maximum size of ${pdfConfig.maxFileSizeMB}MB`);
    }

    // Read file
    const fileBuffer = await fs.readFile(filePath);
    const uint8Array = new Uint8Array(fileBuffer);

    // Parse with both libraries
    const [pdfLibDoc, pdfjsDoc] = await Promise.all([
      this.loadWithPdfLib(fileBuffer),
      this.loadWithPdfjs(uint8Array),
    ]);

    // Extract structure
    const structure = await this.extractStructure(pdfLibDoc, pdfjsDoc);

    // Validate page count
    if (structure.pageCount > pdfConfig.maxPages) {
      throw AppError.badRequest(`PDF exceeds maximum page count of ${pdfConfig.maxPages}`);
    }

    return {
      filePath,
      fileSize: stats.size,
      structure,
      pdfLibDoc,
      pdfjsDoc,
    };
  }

  /**
   * Parse PDF from buffer
   */
  async parseBuffer(buffer: Buffer, fileName = 'document.pdf'): Promise<ParsedPDF> {
    const fileSizeMB = buffer.length / (1024 * 1024);
    if (fileSizeMB > pdfConfig.maxFileSizeMB) {
      throw AppError.badRequest(`PDF file exceeds maximum size of ${pdfConfig.maxFileSizeMB}MB`);
    }

    const uint8Array = new Uint8Array(buffer);

    const [pdfLibDoc, pdfjsDoc] = await Promise.all([
      this.loadWithPdfLib(buffer),
      this.loadWithPdfjs(uint8Array),
    ]);

    const structure = await this.extractStructure(pdfLibDoc, pdfjsDoc);

    if (structure.pageCount > pdfConfig.maxPages) {
      throw AppError.badRequest(`PDF exceeds maximum page count of ${pdfConfig.maxPages}`);
    }

    return {
      filePath: fileName,
      fileSize: buffer.length,
      structure,
      pdfLibDoc,
      pdfjsDoc,
    };
  }

  /**
   * Load PDF with pdf-lib
   */
  private async loadWithPdfLib(buffer: Buffer): Promise<PDFDocument> {
    try {
      return await PDFDocument.load(buffer, {
        ignoreEncryption: true,
        updateMetadata: false,
      });
    } catch (error) {
      throw AppError.badRequest('Failed to parse PDF with pdf-lib: ' + (error as Error).message);
    }
  }

  /**
   * Load PDF with pdfjs-dist
   */
  private async loadWithPdfjs(data: Uint8Array): Promise<pdfjsLib.PDFDocumentProxy> {
    try {
      const loadingTask = pdfjsLib.getDocument({
        data,
        useWorkerFetch: false,
        isEvalSupported: false,
        useSystemFonts: true,
      });
      return await loadingTask.promise;
    } catch (error) {
      throw AppError.badRequest('Failed to parse PDF with pdfjs: ' + (error as Error).message);
    }
  }

  /**
   * Extract document structure
   */
  private async extractStructure(
    pdfLibDoc: PDFDocument,
    pdfjsDoc: pdfjsLib.PDFDocumentProxy
  ): Promise<PDFStructure> {
    const metadata = await this.extractMetadata(pdfLibDoc, pdfjsDoc);
    const pages = await this.extractPageInfo(pdfLibDoc, pdfjsDoc);
    const outline = await this.extractOutline(pdfjsDoc);

    return {
      pageCount: pdfjsDoc.numPages,
      pages,
      metadata,
      outline: outline.length > 0 ? outline : undefined,
    };
  }

  /**
   * Extract metadata from PDF
   */
  private async extractMetadata(
    pdfLibDoc: PDFDocument,
    pdfjsDoc: pdfjsLib.PDFDocumentProxy
  ): Promise<PDFMetadata> {
    const pdfjsMetadata = await pdfjsDoc.getMetadata();
    const info = pdfjsMetadata.info || {};

    // Check for tagged PDF
    const markInfo = this.getMarkInfo(pdfLibDoc);
    const isTagged = markInfo?.Marked === true;

    // Check for outline (bookmarks)
    const outline = await pdfjsDoc.getOutline();
    const hasOutline = outline !== null && outline.length > 0;

    // Get language from catalog
    const language = this.getDocumentLanguage(pdfLibDoc);

    // Check for forms
    const hasAcroForm = this.hasAcroForm(pdfLibDoc);
    const hasXFA = this.hasXFA(pdfLibDoc);

    return {
      title: info.Title || pdfLibDoc.getTitle() || undefined,
      author: info.Author || pdfLibDoc.getAuthor() || undefined,
      subject: info.Subject || pdfLibDoc.getSubject() || undefined,
      keywords: this.parseKeywords(info.Keywords || pdfLibDoc.getKeywords()),
      creator: info.Creator || pdfLibDoc.getCreator() || undefined,
      producer: info.Producer || pdfLibDoc.getProducer() || undefined,
      creationDate: this.parseDate(info.CreationDate || pdfLibDoc.getCreationDate()),
      modificationDate: this.parseDate(info.ModDate || pdfLibDoc.getModificationDate()),
      language,
      pdfVersion: `${pdfjsMetadata.info?.PDFFormatVersion || '1.4'}`,
      isEncrypted: !!pdfjsMetadata.info?.IsAcroFormPresent, // Simplified check
      isLinearized: !!pdfjsMetadata.info?.IsLinearized,
      isTagged,
      hasOutline,
      hasAcroForm,
      hasXFA,
    };
  }

  /**
   * Extract page information
   */
  private async extractPageInfo(
    pdfLibDoc: PDFDocument,
    pdfjsDoc: pdfjsLib.PDFDocumentProxy
  ): Promise<PDFPageInfo[]> {
    const pages: PDFPageInfo[] = [];
    const pdfLibPages = pdfLibDoc.getPages();

    for (let i = 1; i <= pdfjsDoc.numPages; i++) {
      const pdfjsPage = await pdfjsDoc.getPage(i);
      const pdfLibPage = pdfLibPages[i - 1];
      const viewport = pdfjsPage.getViewport({ scale: 1 });
      const annotations = await pdfjsPage.getAnnotations();

      pages.push({
        pageNumber: i,
        width: viewport.width,
        height: viewport.height,
        rotation: pdfLibPage?.getRotation()?.angle || 0,
        hasAnnotations: annotations.length > 0,
        annotationCount: annotations.length,
      });
    }

    return pages;
  }

  /**
   * Extract document outline (bookmarks)
   */
  private async extractOutline(pdfjsDoc: pdfjsLib.PDFDocumentProxy): Promise<PDFOutlineItem[]> {
    const outline = await pdfjsDoc.getOutline();
    if (!outline) return [];

    const processItems = async (items: any[]): Promise<PDFOutlineItem[]> => {
      const result: PDFOutlineItem[] = [];

      for (const item of items) {
        const outlineItem: PDFOutlineItem = {
          title: item.title || 'Untitled',
        };

        // Try to get destination page
        if (item.dest) {
          try {
            if (typeof item.dest === 'string') {
              const dest = await pdfjsDoc.getDestination(item.dest);
              if (dest) {
                const pageIndex = await pdfjsDoc.getPageIndex(dest[0]);
                outlineItem.destination = pageIndex + 1;
              }
            } else if (Array.isArray(item.dest)) {
              const pageIndex = await pdfjsDoc.getPageIndex(item.dest[0]);
              outlineItem.destination = pageIndex + 1;
            }
          } catch {
            // Ignore destination resolution errors
          }
        }

        if (item.items && item.items.length > 0) {
          outlineItem.children = await processItems(item.items);
        }

        result.push(outlineItem);
      }

      return result;
    };

    return processItems(outline);
  }

  /**
   * Get MarkInfo dictionary (for tagged PDF detection)
   */
  private getMarkInfo(pdfLibDoc: PDFDocument): { Marked?: boolean } | null {
    try {
      const catalog = pdfLibDoc.context.lookup(pdfLibDoc.context.trailerInfo.Root);
      if (catalog instanceof PDFDict) {
        const markInfo = catalog.get(PDFName.of('MarkInfo'));
        if (markInfo instanceof PDFDict) {
          const marked = markInfo.get(PDFName.of('Marked'));
          return { Marked: marked?.toString() === 'true' };
        }
      }
    } catch {
      // Ignore errors
    }
    return null;
  }

  /**
   * Get document language from catalog
   */
  private getDocumentLanguage(pdfLibDoc: PDFDocument): string | undefined {
    try {
      const catalog = pdfLibDoc.context.lookup(pdfLibDoc.context.trailerInfo.Root);
      if (catalog instanceof PDFDict) {
        const lang = catalog.get(PDFName.of('Lang'));
        if (lang instanceof PDFString) {
          return lang.decodeText();
        }
      }
    } catch {
      // Ignore errors
    }
    return undefined;
  }

  /**
   * Check if document has AcroForm
   */
  private hasAcroForm(pdfLibDoc: PDFDocument): boolean {
    try {
      const catalog = pdfLibDoc.context.lookup(pdfLibDoc.context.trailerInfo.Root);
      if (catalog instanceof PDFDict) {
        return catalog.has(PDFName.of('AcroForm'));
      }
    } catch {
      // Ignore errors
    }
    return false;
  }

  /**
   * Check if document has XFA forms
   */
  private hasXFA(pdfLibDoc: PDFDocument): boolean {
    try {
      const catalog = pdfLibDoc.context.lookup(pdfLibDoc.context.trailerInfo.Root);
      if (catalog instanceof PDFDict) {
        const acroForm = catalog.get(PDFName.of('AcroForm'));
        if (acroForm instanceof PDFDict) {
          return acroForm.has(PDFName.of('XFA'));
        }
      }
    } catch {
      // Ignore errors
    }
    return false;
  }

  /**
   * Parse keywords string into array
   */
  private parseKeywords(keywords: string | string[] | undefined): string[] | undefined {
    if (!keywords) return undefined;
    if (Array.isArray(keywords)) return keywords;
    return keywords.split(/[,;]/).map(k => k.trim()).filter(k => k.length > 0);
  }

  /**
   * Parse date string or Date object
   */
  private parseDate(date: string | Date | undefined): Date | undefined {
    if (!date) return undefined;
    if (date instanceof Date) return date;

    // PDF date format: D:YYYYMMDDHHmmSSOHH'mm'
    const pdfDateMatch = date.match(/D:(\d{4})(\d{2})?(\d{2})?(\d{2})?(\d{2})?(\d{2})?/);
    if (pdfDateMatch) {
      const [, year, month = '01', day = '01', hour = '00', minute = '00', second = '00'] = pdfDateMatch;
      return new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}Z`);
    }

    // Try standard date parsing
    const parsed = new Date(date);
    return isNaN(parsed.getTime()) ? undefined : parsed;
  }

  /**
   * Close PDF documents and free resources
   */
  async close(parsedPdf: ParsedPDF): Promise<void> {
    try {
      await parsedPdf.pdfjsDoc.destroy();
    } catch {
      // Ignore cleanup errors
    }
  }

  /**
   * Get a specific page from parsed PDF
   */
  async getPage(parsedPdf: ParsedPDF, pageNumber: number): Promise<pdfjsLib.PDFPageProxy> {
    if (pageNumber < 1 || pageNumber > parsedPdf.structure.pageCount) {
      throw AppError.badRequest(`Invalid page number: ${pageNumber}`);
    }
    return parsedPdf.pdfjsDoc.getPage(pageNumber);
  }
}

export const pdfParserService = new PDFParserService();
```

**Create `src/routes/pdf.routes.ts`:**
```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { authenticate } from '../middleware/auth.middleware.js';
import { pdfParserService } from '../services/pdf/pdf-parser.service.js';
import path from 'path';

const router = Router();

// Parse uploaded PDF and return structure
router.post('/parse', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { filePath } = req.body;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { message: 'filePath is required' },
      });
    }

    const parsedPdf = await pdfParserService.parse(filePath);

    // Close the PDF documents after extracting structure
    await pdfParserService.close(parsedPdf);

    res.json({
      success: true,
      data: {
        filePath: parsedPdf.filePath,
        fileSize: parsedPdf.fileSize,
        structure: parsedPdf.structure,
      },
    });
  } catch (error) {
    next(error);
  }
});

// Get PDF metadata only (lighter weight)
router.post('/metadata', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { filePath } = req.body;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { message: 'filePath is required' },
      });
    }

    const parsedPdf = await pdfParserService.parse(filePath);
    const metadata = parsedPdf.structure.metadata;
    await pdfParserService.close(parsedPdf);

    res.json({
      success: true,
      data: metadata,
    });
  } catch (error) {
    next(error);
  }
});

// Validate PDF accessibility basics
router.post('/validate-basics', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { filePath } = req.body;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { message: 'filePath is required' },
      });
    }

    const parsedPdf = await pdfParserService.parse(filePath);
    const { metadata } = parsedPdf.structure;

    // Basic accessibility checks
    const issues: Array<{ type: string; severity: string; message: string }> = [];

    if (!metadata.isTagged) {
      issues.push({
        type: 'not-tagged',
        severity: 'critical',
        message: 'PDF is not tagged. Tagged PDFs are essential for accessibility.',
      });
    }

    if (!metadata.language) {
      issues.push({
        type: 'missing-language',
        severity: 'major',
        message: 'Document language is not specified (WCAG 3.1.1).',
      });
    }

    if (!metadata.title) {
      issues.push({
        type: 'missing-title',
        severity: 'minor',
        message: 'Document title is not set in metadata.',
      });
    }

    if (!metadata.hasOutline && parsedPdf.structure.pageCount > 10) {
      issues.push({
        type: 'missing-bookmarks',
        severity: 'minor',
        message: 'Document has no bookmarks/outline. Consider adding for navigation.',
      });
    }

    await pdfParserService.close(parsedPdf);

    res.json({
      success: true,
      data: {
        isTagged: metadata.isTagged,
        hasLanguage: !!metadata.language,
        hasTitle: !!metadata.title,
        hasOutline: metadata.hasOutline,
        pageCount: parsedPdf.structure.pageCount,
        issues,
        passesBasicChecks: issues.filter(i => i.severity === 'critical').length === 0,
      },
    });
  } catch (error) {
    next(error);
  }
});

export default router;
```

**Update `src/routes/index.ts` to include PDF routes:**

Add import:
```typescript
import pdfRoutes from './pdf.routes.js';
```

Add route:
```typescript
router.use('/pdf', pdfRoutes);
```

## Tasks
1. Install pdf-lib and pdfjs-dist packages
2. Create src/config/pdf.config.ts
3. Create src/services/pdf/pdf-parser.service.ts
4. Create src/routes/pdf.routes.ts
5. Update src/routes/index.ts to include PDF routes
6. Verify server starts without errors
7. Test with a sample PDF if available

## Acceptance Criteria
- [ ] PDF libraries installed
- [ ] PDFParserService parses PDFs with both libraries
- [ ] Metadata extraction (title, author, language, etc.)
- [ ] Page info extraction (dimensions, rotation, annotations)
- [ ] Outline/bookmark extraction
- [ ] Tagged PDF detection
- [ ] API endpoints for parsing and validation
- [ ] Server starts without errors