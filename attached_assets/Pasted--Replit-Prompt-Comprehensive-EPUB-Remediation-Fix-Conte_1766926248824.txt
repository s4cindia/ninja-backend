 Replit Prompt: Comprehensive EPUB Remediation Fix

  Context: The EPUB remediation system has multiple bugs causing:
  1. Corrupted XML in nav files (<nav role="..." <nav epub:type="...">)
  2. Duplicate metadata entries
  3. Multiple main landmarks across files
  4. Cheerio usage corrupting XHTML

  This prompt provides a complete rewrite of the problematic methods in src/services/epub/epub-modifier.service.ts

  ---
  Part 1: Replace addAccessibilityMetadata method

  This version checks for existing metadata before adding:

    async addAccessibilityMetadata(
      zip: JSZip,
      features: string[] = ['structuralNavigation', 'tableOfContents', 'readingOrder']
    ): Promise<ModificationResult[]> {
      const results: ModificationResult[] = [];
      const opf = await this.getOPF(zip);

      if (!opf) {
        return [{
          success: false,
          filePath: 'content.opf',
          modificationType: 'add_accessibility_metadata',
          description: 'Failed to locate OPF file',
        }];
      }

      let modified = opf.content;
      const metadataToAdd: string[] = [];

      // Helper to check if metadata already exists
      const hasMetadata = (property: string, value?: string): boolean => {
        if (value) {
          const pattern = new RegExp(`<meta[^>]*property\\s*=\\s*["']${property}["'][^>]*>\\s*${value}\\s*</meta>`, 'i');
          return pattern.test(modified);
        }
        const pattern = new RegExp(`<meta[^>]*property\\s*=\\s*["']${property}["']`, 'i');
        return pattern.test(modified);
      };

      // Add accessibility features (only if not present)
      for (const feature of features) {
        if (!hasMetadata('schema:accessibilityFeature', feature)) {
          metadataToAdd.push(`<meta property="schema:accessibilityFeature">${feature}</meta>`);
        }
      }

      // Add access mode (only if not present)
      if (!hasMetadata('schema:accessMode', 'textual')) {
        metadataToAdd.push('<meta property="schema:accessMode">textual</meta>');
      }

      // Add access mode sufficient (only if not present)
      if (!hasMetadata('schema:accessModeSufficient', 'textual')) {
        metadataToAdd.push('<meta property="schema:accessModeSufficient">textual</meta>');
      }

      // Add accessibility hazard (only if not present)
      if (!hasMetadata('schema:accessibilityHazard')) {
        metadataToAdd.push('<meta property="schema:accessibilityHazard">none</meta>');
      }

      if (metadataToAdd.length === 0) {
        return [{
          success: true,
          filePath: opf.path,
          modificationType: 'add_accessibility_metadata',
          description: 'Accessibility metadata already present',
        }];
      }

      const insertContent = '\n    ' + metadataToAdd.join('\n    ');
      modified = modified.replace('</metadata>', insertContent + '\n  </metadata>');

      await this.updateOPF(zip, opf.path, modified);

      results.push({
        success: true,
        filePath: opf.path,
        modificationType: 'add_accessibility_metadata',
        description: `Added ${metadataToAdd.length} accessibility metadata elements`,
        after: metadataToAdd.join('\n'),
      });

      return results;
    }
