## Context
Building an image extraction service that extracts images from PDFs for accessibility validation. This is critical for alt text checking and ensuring all images have appropriate descriptions.

## Current State
- US-2.4.1 complete with PDFParserService
- US-2.4.2 complete with TextExtractorService
- Need to extract images for alt text validation

## Objective
Create an image extraction service that extracts embedded images from PDFs with metadata, position information, and base64 encoding for AI analysis.

## Technical Requirements

**Create `src/services/pdf/image-extractor.service.ts`:**
```typescript
import * as pdfjsLib from 'pdfjs-dist';
import { PDFDocument, PDFName, PDFDict, PDFStream, PDFRawStream } from 'pdf-lib';
import sharp from 'sharp';
import { pdfParserService, ParsedPDF } from './pdf-parser.service.js';

export interface ImageInfo {
  id: string;
  pageNumber: number;
  index: number;
  position: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  dimensions: {
    width: number;
    height: number;
  };
  format: 'jpeg' | 'png' | 'jbig2' | 'jpx' | 'unknown';
  colorSpace: string;
  bitsPerComponent: number;
  hasAlpha: boolean;
  fileSizeBytes: number;
  altText?: string;
  isDecorative?: boolean;
  base64?: string;
  mimeType: string;
}

export interface PageImages {
  pageNumber: number;
  images: ImageInfo[];
  totalImages: number;
}

export interface DocumentImages {
  pages: PageImages[];
  totalImages: number;
  imageFormats: Record<string, number>;
  imagesWithAltText: number;
  imagesWithoutAltText: number;
  decorativeImages: number;
}

export interface ExtractionOptions {
  includeBase64?: boolean;
  maxImageSize?: number; // Max dimension in pixels
  pageRange?: { start: number; end: number };
  formats?: ('jpeg' | 'png' | 'jbig2' | 'jpx')[];
  minWidth?: number;
  minHeight?: number;
}

class ImageExtractorService {
  private readonly DEFAULT_MAX_SIZE = 1024; // Max dimension for extracted images
  private readonly MIN_IMAGE_SIZE = 10; // Minimum pixels to consider as real image

  /**
   * Extract all images from a parsed PDF
   */
  async extractImages(
    parsedPdf: ParsedPDF,
    options: ExtractionOptions = {}
  ): Promise<DocumentImages> {
    const {
      includeBase64 = false,
      maxImageSize = this.DEFAULT_MAX_SIZE,
      pageRange,
      formats,
      minWidth = this.MIN_IMAGE_SIZE,
      minHeight = this.MIN_IMAGE_SIZE,
    } = options;

    const pages: PageImages[] = [];
    let totalImages = 0;
    const imageFormats: Record<string, number> = {};
    let imagesWithAltText = 0;
    let imagesWithoutAltText = 0;
    let decorativeImages = 0;

    const startPage = pageRange?.start || 1;
    const endPage = pageRange?.end || parsedPdf.structure.pageCount;

    for (let pageNum = startPage; pageNum <= endPage; pageNum++) {
      const pageImages = await this.extractPageImages(
        parsedPdf,
        pageNum,
        {
          includeBase64,
          maxImageSize,
          formats,
          minWidth,
          minHeight,
        }
      );

      pages.push(pageImages);
      totalImages += pageImages.totalImages;

      // Aggregate statistics
      for (const img of pageImages.images) {
        imageFormats[img.format] = (imageFormats[img.format] || 0) + 1;
        
        if (img.isDecorative) {
          decorativeImages++;
        } else if (img.altText) {
          imagesWithAltText++;
        } else {
          imagesWithoutAltText++;
        }
      }
    }

    return {
      pages,
      totalImages,
      imageFormats,
      imagesWithAltText,
      imagesWithoutAltText,
      decorativeImages,
    };
  }

  /**
   * Extract images from a single page
   */
  private async extractPageImages(
    parsedPdf: ParsedPDF,
    pageNumber: number,
    options: {
      includeBase64: boolean;
      maxImageSize: number;
      formats?: ('jpeg' | 'png' | 'jbig2' | 'jpx')[];
      minWidth: number;
      minHeight: number;
    }
  ): Promise<PageImages> {
    const images: ImageInfo[] = [];
    
    try {
      const page = await parsedPdf.pdfjsDoc.getPage(pageNumber);
      const viewport = page.getViewport({ scale: 1 });
      const operatorList = await page.getOperatorList();
      
      // Track image positions from operator list
      const imagePositions = this.extractImagePositions(operatorList, viewport);
      
      // Get images using pdf-lib
      const pdfLibPage = parsedPdf.pdfLibDoc.getPages()[pageNumber - 1];
      const resources = pdfLibPage?.node?.get(PDFName.of('Resources'));
      
      if (resources instanceof PDFDict) {
        const xObjects = resources.get(PDFName.of('XObject'));
        
        if (xObjects instanceof PDFDict) {
          const entries = xObjects.entries();
          let index = 0;
          
          for (const [name, ref] of entries) {
            try {
              const xObject = parsedPdf.pdfLibDoc.context.lookup(ref);
              
              if (xObject instanceof PDFRawStream || xObject instanceof PDFStream) {
                const subtype = xObject.dict.get(PDFName.of('Subtype'));
                
                if (subtype?.toString() === '/Image') {
                  const imageInfo = await this.processImage(
                    xObject,
                    name.toString().replace('/', ''),
                    pageNumber,
                    index,
                    imagePositions[index] || { x: 0, y: 0, width: 100, height: 100 },
                    viewport,
                    options
                  );
                  
                  if (imageInfo && 
                      imageInfo.dimensions.width >= options.minWidth &&
                      imageInfo.dimensions.height >= options.minHeight) {
                    
                    // Filter by format if specified
                    if (!options.formats || options.formats.includes(imageInfo.format as any)) {
                      images.push(imageInfo);
                    }
                  }
                  
                  index++;
                }
              }
            } catch (err) {
              console.warn(`Failed to process image on page ${pageNumber}:`, err);
            }
          }
        }
      }
    } catch (err) {
      console.warn(`Failed to extract images from page ${pageNumber}:`, err);
    }

    return {
      pageNumber,
      images,
      totalImages: images.length,
    };
  }

  /**
   * Extract image positions from operator list
   */
  private extractImagePositions(
    operatorList: any,
    viewport: pdfjsLib.PageViewport
  ): Array<{ x: number; y: number; width: number; height: number }> {
    const positions: Array<{ x: number; y: number; width: number; height: number }> = [];
    const OPS = pdfjsLib.OPS;
    
    let currentTransform = [1, 0, 0, 1, 0, 0];
    
    for (let i = 0; i < operatorList.fnArray.length; i++) {
      const fn = operatorList.fnArray[i];
      const args = operatorList.argsArray[i];
      
      if (fn === OPS.transform) {
        currentTransform = this.multiplyTransforms(currentTransform, args);
      } else if (fn === OPS.paintImageXObject || fn === OPS.paintImageXObjectRepeat) {
        // Extract position from current transform
        const [a, b, c, d, e, f] = currentTransform;
        const width = Math.abs(a);
        const height = Math.abs(d);
        const x = e;
        const y = viewport.height - f - height;
        
        positions.push({ x, y, width, height });
      }
    }
    
    return positions;
  }

  /**
   * Multiply two transformation matrices
   */
  private multiplyTransforms(t1: number[], t2: number[]): number[] {
    return [
      t1[0] * t2[0] + t1[2] * t2[1],
      t1[1] * t2[0] + t1[3] * t2[1],
      t1[0] * t2[2] + t1[2] * t2[3],
      t1[1] * t2[2] + t1[3] * t2[3],
      t1[0] * t2[4] + t1[2] * t2[5] + t1[4],
      t1[1] * t2[4] + t1[3] * t2[5] + t1[5],
    ];
  }

  /**
   * Process a single image
   */
  private async processImage(
    xObject: PDFRawStream | PDFStream,
    name: string,
    pageNumber: number,
    index: number,
    position: { x: number; y: number; width: number; height: number },
    viewport: pdfjsLib.PageViewport,
    options: { includeBase64: boolean; maxImageSize: number }
  ): Promise<ImageInfo | null> {
    try {
      const dict = xObject.dict;
      
      // Get image properties
      const width = dict.get(PDFName.of('Width'))?.toString() || '0';
      const height = dict.get(PDFName.of('Height'))?.toString() || '0';
      const bitsPerComponent = dict.get(PDFName.of('BitsPerComponent'))?.toString() || '8';
      const colorSpace = dict.get(PDFName.of('ColorSpace'))?.toString() || '/DeviceRGB';
      const filter = dict.get(PDFName.of('Filter'))?.toString() || '';
      
      // Determine format
      let format: ImageInfo['format'] = 'unknown';
      let mimeType = 'image/unknown';
      
      if (filter.includes('DCTDecode')) {
        format = 'jpeg';
        mimeType = 'image/jpeg';
      } else if (filter.includes('FlateDecode') || filter.includes('LZWDecode')) {
        format = 'png';
        mimeType = 'image/png';
      } else if (filter.includes('JBIG2Decode')) {
        format = 'jbig2';
        mimeType = 'image/jbig2';
      } else if (filter.includes('JPXDecode')) {
        format = 'jpx';
        mimeType = 'image/jp2';
      }
      
      // Get raw image data
      let imageData: Uint8Array;
      if (xObject instanceof PDFRawStream) {
        imageData = xObject.contents;
      } else {
        imageData = xObject.getContents();
      }
      
      const fileSizeBytes = imageData.length;
      
      // Check for alpha channel
      const sMask = dict.get(PDFName.of('SMask'));
      const hasAlpha = sMask !== undefined;
      
      // Create image info
      const imageInfo: ImageInfo = {
        id: `img_p${pageNumber}_${index}_${name}`,
        pageNumber,
        index,
        position: {
          x: Math.round(position.x),
          y: Math.round(position.y),
          width: Math.round(position.width),
          height: Math.round(position.height),
        },
        dimensions: {
          width: parseInt(width, 10),
          height: parseInt(height, 10),
        },
        format,
        colorSpace: colorSpace.replace('/', ''),
        bitsPerComponent: parseInt(bitsPerComponent, 10),
        hasAlpha,
        fileSizeBytes,
        mimeType,
      };
      
      // Extract base64 if requested
      if (options.includeBase64 && (format === 'jpeg' || format === 'png')) {
        try {
          const base64 = await this.convertToBase64(
            imageData,
            format,
            imageInfo.dimensions.width,
            imageInfo.dimensions.height,
            options.maxImageSize
          );
          
          if (base64) {
            imageInfo.base64 = base64;
          }
        } catch (err) {
          console.warn(`Failed to convert image to base64:`, err);
        }
      }
      
      return imageInfo;
    } catch (err) {
      console.warn(`Failed to process image:`, err);
      return null;
    }
  }

  /**
   * Convert image data to base64
   */
  private async convertToBase64(
    data: Uint8Array,
    format: 'jpeg' | 'png',
    width: number,
    height: number,
    maxSize: number
  ): Promise<string | null> {
    try {
      // If already JPEG, can use directly
      if (format === 'jpeg') {
        // Check if valid JPEG
        if (data[0] === 0xFF && data[1] === 0xD8) {
          // Resize if needed
          if (width > maxSize || height > maxSize) {
            const resized = await sharp(Buffer.from(data))
              .resize(maxSize, maxSize, { fit: 'inside' })
              .jpeg({ quality: 85 })
              .toBuffer();
            return resized.toString('base64');
          }
          return Buffer.from(data).toString('base64');
        }
      }
      
      // For other formats, try to convert with sharp
      try {
        const converted = await sharp(Buffer.from(data), {
          raw: format !== 'jpeg' ? {
            width,
            height,
            channels: 3,
          } : undefined,
        })
          .resize(maxSize, maxSize, { fit: 'inside' })
          .png()
          .toBuffer();
        
        return converted.toString('base64');
      } catch {
        // If sharp fails, return null
        return null;
      }
    } catch (err) {
      return null;
    }
  }

  /**
   * Extract images from a file path (convenience method)
   */
  async extractFromFile(
    filePath: string,
    options: ExtractionOptions = {}
  ): Promise<DocumentImages> {
    const parsedPdf = await pdfParserService.parse(filePath);
    try {
      return await this.extractImages(parsedPdf, options);
    } finally {
      await pdfParserService.close(parsedPdf);
    }
  }

  /**
   * Get images from specific pages
   */
  async extractFromPages(
    parsedPdf: ParsedPDF,
    pageNumbers: number[],
    options: ExtractionOptions = {}
  ): Promise<PageImages[]> {
    const pages: PageImages[] = [];
    
    for (const pageNum of pageNumbers) {
      const pageImages = await this.extractPageImages(parsedPdf, pageNum, {
        includeBase64: options.includeBase64 ?? false,
        maxImageSize: options.maxImageSize ?? this.DEFAULT_MAX_SIZE,
        formats: options.formats,
        minWidth: options.minWidth ?? this.MIN_IMAGE_SIZE,
        minHeight: options.minHeight ?? this.MIN_IMAGE_SIZE,
      });
      pages.push(pageImages);
    }
    
    return pages;
  }

  /**
   * Get a single image by ID
   */
  async getImageById(
    parsedPdf: ParsedPDF,
    imageId: string,
    includeBase64 = true
  ): Promise<ImageInfo | null> {
    // Parse image ID: img_p{pageNumber}_{index}_{name}
    const match = imageId.match(/^img_p(\d+)_(\d+)_(.+)$/);
    if (!match) return null;
    
    const pageNumber = parseInt(match[1], 10);
    const index = parseInt(match[2], 10);
    
    const pageImages = await this.extractPageImages(parsedPdf, pageNumber, {
      includeBase64,
      maxImageSize: this.DEFAULT_MAX_SIZE,
      minWidth: 1,
      minHeight: 1,
    });
    
    return pageImages.images.find(img => img.id === imageId) || null;
  }

  /**
   * Get image statistics without extracting full data
   */
  async getImageStats(parsedPdf: ParsedPDF): Promise<{
    totalImages: number;
    pagesWith Images: number;
    pagesWithoutImages: number;
    averageImagesPerPage: number;
    formatDistribution: Record<string, number>;
  }> {
    const images = await this.extractImages(parsedPdf, { includeBase64: false });
    
    const pagesWithImages = images.pages.filter(p => p.totalImages > 0).length;
    
    return {
      totalImages: images.totalImages,
      pagesWithImages,
      pagesWithoutImages: images.pages.length - pagesWithImages,
      averageImagesPerPage: images.totalImages / images.pages.length,
      formatDistribution: images.imageFormats,
    };
  }
}

export const imageExtractorService = new ImageExtractorService();
```

**Install sharp if not already installed:**
```bash
npm install sharp
```

**Update `src/routes/pdf.routes.ts` to add image extraction endpoints:**

Add import at top:
```typescript
import { imageExtractorService } from '../services/pdf/image-extractor.service.js';
```

Add new endpoints:
```typescript
// Extract all images from PDF
router.post('/extract-images', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { filePath, options = {} } = req.body;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { message: 'filePath is required' },
      });
    }

    // Don't include base64 by default (large response)
    const extractionOptions = {
      includeBase64: options.includeBase64 ?? false,
      maxImageSize: options.maxImageSize ?? 512,
      pageRange: options.pageRange,
      minWidth: options.minWidth ?? 20,
      minHeight: options.minHeight ?? 20,
    };

    const documentImages = await imageExtractorService.extractFromFile(filePath, extractionOptions);

    res.json({
      success: true,
      data: {
        totalImages: documentImages.totalImages,
        imageFormats: documentImages.imageFormats,
        imagesWithAltText: documentImages.imagesWithAltText,
        imagesWithoutAltText: documentImages.imagesWithoutAltText,
        decorativeImages: documentImages.decorativeImages,
        pages: documentImages.pages.map(p => ({
          pageNumber: p.pageNumber,
          totalImages: p.totalImages,
          images: p.images.map(img => ({
            id: img.id,
            position: img.position,
            dimensions: img.dimensions,
            format: img.format,
            colorSpace: img.colorSpace,
            fileSizeBytes: img.fileSizeBytes,
            hasAlpha: img.hasAlpha,
            altText: img.altText,
            isDecorative: img.isDecorative,
            // Only include base64 if requested
            ...(extractionOptions.includeBase64 && img.base64 ? { base64: img.base64, mimeType: img.mimeType } : {}),
          })),
        })),
      },
    });
  } catch (error) {
    next(error);
  }
});

// Get single image by ID with base64
router.post('/image/:imageId', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { filePath } = req.body;
    const { imageId } = req.params;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { message: 'filePath is required' },
      });
    }

    const parsedPdf = await pdfParserService.parse(filePath);
    
    try {
      const image = await imageExtractorService.getImageById(parsedPdf, imageId, true);
      
      if (!image) {
        return res.status(404).json({
          success: false,
          error: { message: 'Image not found' },
        });
      }
      
      res.json({
        success: true,
        data: image,
      });
    } finally {
      await pdfParserService.close(parsedPdf);
    }
  } catch (error) {
    next(error);
  }
});

// Get image statistics
router.post('/image-stats', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { filePath } = req.body;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { message: 'filePath is required' },
      });
    }

    const parsedPdf = await pdfParserService.parse(filePath);
    
    try {
      const stats = await imageExtractorService.getImageStats(parsedPdf);
      
      res.json({
        success: true,
        data: stats,
      });
    } finally {
      await pdfParserService.close(parsedPdf);
    }
  } catch (error) {
    next(error);
  }
});
```

## Tasks
1. Install sharp package for image processing
2. Create src/services/pdf/image-extractor.service.ts
3. Update src/routes/pdf.routes.ts with image extraction endpoints
4. Verify server starts without errors

## Acceptance Criteria
- [ ] ImageExtractorService extracts images from PDFs
- [ ] Image metadata extracted (dimensions, format, colorSpace)
- [ ] Image positions tracked on page
- [ ] Base64 encoding available for AI analysis
- [ ] Image resizing for large images
- [ ] /api/v1/pdf/extract-images endpoint working
- [ ] /api/v1/pdf/image/:imageId endpoint working
- [ ] /api/v1/pdf/image-stats endpoint working
- [ ] Server starts without errors