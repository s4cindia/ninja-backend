 Issues Remaining

  1. XML Corruption (RSC-016) - Cheerio is still corrupting the XML
  2. Mimetype Corruption (PKG-007) - JSZip is compressing the mimetype file
  3. Invalid Roles (RSC-005) - Still using invalid roles
  4. Deprecated Role (RSC-017) - doc-endnote is deprecated
  5. Role Not Allowed (ARIA-ALLOWED-ROLE) - doc-cover not allowed on certain elements

  ---
  Prompt 49: Backend - Complete Fix for EPUB Modification

  File: src/services/epub/epub-modifier.service.ts

  Replace addAriaRolesToEpubTypes with this version that:
  1. Uses pure string replacement (no cheerio)
  2. Uses only valid, non-deprecated ARIA roles

  async addAriaRolesToEpubTypes(
    zip: JSZip,
    epubTypesToFix: Array<{ epubType: string; role: string }>
  ): Promise<ModificationResult[]> {
    const results: ModificationResult[] = [];

    // VALID role mappings (no deprecated roles, no invalid roles)
    const validRoleMapping: Record<string, string> = {
      'chapter': 'doc-chapter',
      'part': 'doc-part',
      'toc': 'doc-toc',
      'landmarks': 'navigation',
      'frontmatter': 'doc-prologue',
      'bodymatter': 'main',
      'backmatter': 'doc-epilogue',
      'titlepage': 'region',        // doc-cover not universally valid
      'dedication': 'doc-dedication',
      'epigraph': 'doc-epigraph',
      'foreword': 'doc-foreword',
      'preface': 'doc-preface',
      'introduction': 'doc-introduction',
      'prologue': 'doc-prologue',
      'epilogue': 'doc-epilogue',
      'afterword': 'doc-afterword',
      'appendix': 'doc-appendix',
      'glossary': 'doc-glossary',
      'bibliography': 'doc-bibliography',
      'index': 'doc-index',
      'colophon': 'doc-colophon',
      'acknowledgments': 'doc-acknowledgments',
      'noteref': 'doc-noteref',
      'footnote': 'note',           // doc-footnote doesn't exist
      'endnote': 'note',            // doc-endnote is deprecated
      'rearnote': 'note',           // Use 'note' instead
      'rearnotes': 'doc-endnotes',
      'footnotes': 'doc-endnotes',
      'endnotes': 'doc-endnotes',
    };

    const xhtmlFiles = Object.keys(zip.files).filter(path =>
      /\.(xhtml|html|htm)$/i.test(path) && !zip.files[path].dir
    );

    for (const filePath of xhtmlFiles) {
      try {
        let content = await zip.file(filePath)?.async('text');
        if (!content) continue;

        let fileModified = false;
        const originalContent = content;

        for (const { epubType } of epubTypesToFix) {
          // Get the VALID role (override any invalid role passed in)
          const role = validRoleMapping[epubType.toLowerCase()] || 'region';

          // Pattern to find epub:type="value" without existing role
          // Match: epub:type="epubType" or epub:type="something epubType" or epub:type="epubType something"
          const patterns = [
            // Exact match: epub:type="epubType"
            new RegExp(`(epub:type=["'])${epubType}(["'])(?![^>]*\\brole=)`, 'g'),
            // With other values: epub:type="... epubType ..."
            new RegExp(`(epub:type=["'][^"']*\\b)${epubType}(\\b[^"']*["'])(?![^>]*\\brole=)`, 'g'),
          ];

          for (const pattern of patterns) {
            const matches = content.match(pattern);
            if (matches && matches.length > 0) {
              // Add role attribute after epub:type
              content = content.replace(pattern, `$1${epubType}$2 role="${role}"`);

              if (content !== originalContent) {
                fileModified = true;
                results.push({
                  success: true,
                  filePath,
                  modificationType: 'add_role',
                  description: `Added role="${role}" to epub:type="${epubType}"`,
                });
              }
            }
          }
        }

        if (fileModified) {
          zip.file(filePath, content);
          console.log(`Modified: ${filePath}`);
        }
      } catch (err) {
        console.error(`Error processing ${filePath}:`, err);
      }
    }

    return results;
  }

  ---
  Also fix the mimetype compression in saveEPUB:

  async saveEPUB(zip: JSZip): Promise<Buffer> {
    // Ensure mimetype is first and uncompressed
    const mimetypeContent = 'application/epub+zip';
    zip.file('mimetype', mimetypeContent, { compression: 'STORE' });

    return zip.generateAsync({
      type: 'nodebuffer',
      compression: 'DEFLATE',
      compressionOptions: { level: 9 },
      // Keep mimetype uncompressed
      encodeFileName: (filename) => filename,
    }, (metadata) => {
      // Force mimetype to be uncompressed
      if (metadata.currentFile === 'mimetype') {
        metadata.compression = 'STORE';
      }
    });
  }

  ---
  Also update the scanEpubTypes to return VALID roles:

  // In scanEpubTypes, update roleMapping to use only valid roles
  const roleMapping: Record<string, string> = {
    'chapter': 'doc-chapter',
    'part': 'doc-part',
    'toc': 'doc-toc',
    'landmarks': 'navigation',
    'frontmatter': 'doc-prologue',
    'bodymatter': 'main',
    'backmatter': 'doc-epilogue',
    'titlepage': 'region',
    'dedication': 'doc-dedication',
    'epigraph': 'doc-epigraph',
    'noteref': 'doc-noteref',
    'rearnote': 'note',
    'rearnotes': 'doc-endnotes',
    // ... etc with valid roles only
  };
