## Context
Extending file handling with metadata extraction, status tracking, and additional query capabilities.

## Current State
- File upload working
- Files stored in persistent storage
- Basic file service created

## Objective
Enhance file service with metadata extraction, status management, and advanced querying.

## Technical Requirements

**Create `src/schemas/file.schemas.ts`:**
```typescript
import { z } from 'zod';

export const listFilesSchema = z.object({
  query: z.object({
    page: z.string().optional().transform((val) => val ? parseInt(val, 10) : 1),
    limit: z.string().optional().transform((val) => val ? parseInt(val, 10) : 20),
    status: z.enum(['UPLOADED', 'PROCESSING', 'PROCESSED', 'ERROR']).optional(),
    mimeType: z.string().optional(),
    sortBy: z.enum(['createdAt', 'size', 'originalName']).optional().default('createdAt'),
    sortOrder: z.enum(['asc', 'desc']).optional().default('desc'),
  }),
});

export const fileIdParamSchema = z.object({
  params: z.object({
    id: z.string().uuid('Invalid file ID'),
  }),
});

export type ListFilesQuery = z.infer<typeof listFilesSchema>['query'];
```

**Update `src/services/file.service.ts`** - Add these methods to the FileService class:
```typescript
async updateFileStatus(
  id: string, 
  tenantId: string,
  status: FileStatus, 
  metadata?: Record<string, unknown>
) {
  // Verify file belongs to tenant
  await this.getFile(id, tenantId);

  return prisma.file.update({
    where: { id },
    data: {
      status,
      ...(metadata && { 
        metadata: metadata as any 
      }),
    },
  });
}

async updateFileMetadata(
  id: string, 
  tenantId: string,
  metadata: Record<string, unknown>
) {
  const file = await this.getFile(id, tenantId);

  const existingMetadata = (file.metadata as Record<string, unknown>) || {};

  return prisma.file.update({
    where: { id },
    data: {
      metadata: { ...existingMetadata, ...metadata } as any,
    },
  });
}

async getFilesByStatus(tenantId: string, status: FileStatus) {
  return prisma.file.findMany({
    where: { 
      tenantId, 
      status,
      deletedAt: null,
    },
    orderBy: { createdAt: 'desc' },
  });
}

async listFilesAdvanced(
  tenantId: string, 
  options: {
    page?: number;
    limit?: number;
    status?: FileStatus;
    mimeType?: string;
    sortBy?: 'createdAt' | 'size' | 'originalName';
    sortOrder?: 'asc' | 'desc';
  } = {}
) {
  const { 
    page = 1, 
    limit = 20, 
    status, 
    mimeType,
    sortBy = 'createdAt',
    sortOrder = 'desc',
  } = options;
  
  const skip = (page - 1) * limit;

  const where = {
    tenantId,
    deletedAt: null,
    ...(status && { status }),
    ...(mimeType && { mimeType }),
  };

  const [files, total] = await Promise.all([
    prisma.file.findMany({
      where,
      skip,
      take: limit,
      orderBy: { [sortBy]: sortOrder },
      select: {
        id: true,
        filename: true,
        originalName: true,
        mimeType: true,
        size: true,
        status: true,
        metadata: true,
        createdAt: true,
        updatedAt: true,
      },
    }),
    prisma.file.count({ where }),
  ]);

  return {
    files,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  };
}

async getFileStats(tenantId: string) {
  const [totalFiles, totalSize, byStatus, byType] = await Promise.all([
    prisma.file.count({ 
      where: { tenantId, deletedAt: null } 
    }),
    prisma.file.aggregate({
      where: { tenantId, deletedAt: null },
      _sum: { size: true },
    }),
    prisma.file.groupBy({
      by: ['status'],
      where: { tenantId, deletedAt: null },
      _count: true,
    }),
    prisma.file.groupBy({
      by: ['mimeType'],
      where: { tenantId, deletedAt: null },
      _count: true,
    }),
  ]);

  return {
    totalFiles,
    totalSize: totalSize._sum.size || 0,
    byStatus: byStatus.reduce((acc, item) => {
      acc[item.status] = item._count;
      return acc;
    }, {} as Record<string, number>),
    byType: byType.reduce((acc, item) => {
      acc[item.mimeType] = item._count;
      return acc;
    }, {} as Record<string, number>),
  };
}
```

**Update `src/controllers/file.controller.ts`** - Add these methods:
```typescript
async listAdvanced(req: Request, res: Response, next: NextFunction) {
  try {
    if (!req.user) {
      throw AppError.unauthorized('Not authenticated');
    }

    const { page, limit, status, mimeType, sortBy, sortOrder } = req.query as any;

    const result = await fileService.listFilesAdvanced(req.user.tenantId, {
      page,
      limit,
      status,
      mimeType,
      sortBy,
      sortOrder,
    });

    res.json({
      success: true,
      data: result,
    });
  } catch (error) {
    next(error);
  }
}

async getStats(req: Request, res: Response, next: NextFunction) {
  try {
    if (!req.user) {
      throw AppError.unauthorized('Not authenticated');
    }

    const stats = await fileService.getFileStats(req.user.tenantId);

    res.json({
      success: true,
      data: stats,
    });
  } catch (error) {
    next(error);
  }
}

async updateStatus(req: Request, res: Response, next: NextFunction) {
  try {
    if (!req.user) {
      throw AppError.unauthorized('Not authenticated');
    }

    const { status, metadata } = req.body;

    const file = await fileService.updateFileStatus(
      req.params.id,
      req.user.tenantId,
      status,
      metadata
    );

    res.json({
      success: true,
      data: file,
    });
  } catch (error) {
    next(error);
  }
}
```

**Update `src/routes/files.routes.ts`** - Add new routes:
```typescript
import { validate } from '../middleware/validate.middleware.js';
import { listFilesSchema, fileIdParamSchema } from '../schemas/file.schemas.js';

// Update existing list route to use advanced listing
router.get('/', validate(listFilesSchema), (req, res, next) => 
  fileController.listAdvanced(req, res, next)
);

// GET /api/v1/files/stats - Get file statistics
router.get('/stats', (req, res, next) => fileController.getStats(req, res, next));

// PATCH /api/v1/files/:id/status - Update file status (internal use)
router.patch('/:id/status', validate(fileIdParamSchema), (req, res, next) => 
  fileController.updateStatus(req, res, next)
);
```

**Create `src/utils/file-helpers.ts`:**
```typescript
export function formatFileSize(bytes: number): string {
  const units = ['B', 'KB', 'MB', 'GB'];
  let size = bytes;
  let unitIndex = 0;

  while (size >= 1024 && unitIndex < units.length - 1) {
    size /= 1024;
    unitIndex++;
  }

  return `${size.toFixed(2)} ${units[unitIndex]}`;
}

export function getFileExtension(filename: string): string {
  const parts = filename.split('.');
  return parts.length > 1 ? parts.pop()!.toLowerCase() : '';
}

export function isValidFileType(mimeType: string, allowedTypes: string[]): boolean {
  return allowedTypes.includes(mimeType);
}

export function generateStoragePath(tenantId: string, filename: string): string {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  return `${tenantId}/${year}/${month}/${filename}`;
}
```

## Tasks
1. Create src/schemas/file.schemas.ts with list and param schemas
2. Add new methods to FileService: updateFileStatus, updateFileMetadata, getFilesByStatus, listFilesAdvanced, getFileStats
3. Add new methods to FileController: listAdvanced, getStats, updateStatus
4. Update files.routes.ts with new endpoints and validation
5. Create src/utils/file-helpers.ts with utility functions
6. Test all new endpoints

## Acceptance Criteria
- [ ] GET /api/v1/files supports filtering by status and mimeType
- [ ] GET /api/v1/files supports sorting by createdAt, size, originalName
- [ ] GET /api/v1/files/stats returns file statistics
- [ ] PATCH /api/v1/files/:id/status updates file status
- [ ] File metadata can be updated and merged
- [ ] Status transitions are tracked