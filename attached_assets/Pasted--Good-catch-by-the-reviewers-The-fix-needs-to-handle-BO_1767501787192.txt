 Good catch by the reviewers. The fix needs to handle BOTH cases:
  1. Documents starting with h2+ (shift all up)
  2. Documents starting with h1 but skipping levels (h1→h3)

  Replit Agent prompt:

  Replace the fixHeadingHierarchy method in src/services/epub/epub-modifier.service.ts with this complete version that handles both cases:

  async fixHeadingHierarchy(zip: JSZip): Promise<ModificationResult[]> {
    const results: ModificationResult[] = [];
    const files = Object.keys(zip.files);

    for (const filePath of files) {
      if (!filePath.match(/\.(html|xhtml|htm)$/i)) continue;

      const content = await zip.file(filePath)?.async('text');
      if (!content) continue;

      const $ = cheerio.load(content, { xmlMode: true });
      let modified = false;
      const changes: string[] = [];

      const headings = $('h1, h2, h3, h4, h5, h6').toArray();
      if (headings.length === 0) continue;

      // Helper to escape attribute values
      const escapeAttr = (str: string): string => {
        return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      };

      // Find the minimum heading level in the document
      const levels = headings.map(el => parseInt(el.tagName.charAt(1)));
      const minLevel = Math.min(...levels);

      // Case 1: Document doesn't start with h1 - shift all headings up
      if (minLevel > 1) {
        const shift = minLevel - 1;

        // Process in reverse order to avoid conflicts
        for (let i = headings.length - 1; i >= 0; i--) {
          const el = headings[i];
          const oldLevel = parseInt(el.tagName.charAt(1));
          const newLevel = Math.max(1, oldLevel - shift);

          if (oldLevel !== newLevel) {
            const $el = $(el);
            const headingContent = $el.html();
            const attrs = el.attribs || {};
            const attrString = Object.entries(attrs)
              .map(([k, v]) => `${k}="${escapeAttr(v)}"`)
              .join(' ');

            $el.replaceWith(`<h${newLevel}${attrString ? ' ' + attrString : ''}>${headingContent}</h${newLevel}>`);
            changes.push(`h${oldLevel} → h${newLevel}`);
            modified = true;
          }
        }
      } else {
        // Case 2: Document starts with h1 but may have skipped levels (h1→h3)
        // Normalize each heading to at most one level deeper than expected
        let expectedMaxLevel = 1;

        for (const el of headings) {
          const oldLevel = parseInt(el.tagName.charAt(1));

          if (oldLevel > expectedMaxLevel + 1) {
            const newLevel = expectedMaxLevel + 1;
            const $el = $(el);
            const headingContent = $el.html();
            const attrs = el.attribs || {};
            const attrString = Object.entries(attrs)
              .map(([k, v]) => `${k}="${escapeAttr(v)}"`)
              .join(' ');

            $el.replaceWith(`<h${newLevel}${attrString ? ' ' + attrString : ''}>${headingContent}</h${newLevel}>`);
            changes.push(`h${oldLevel} → h${newLevel}`);
            modified = true;
            expectedMaxLevel = newLevel;
          } else {
            expectedMaxLevel = Math.max(expectedMaxLevel, oldLevel);
          }
        }
      }

      if (modified) {
        zip.file(filePath, $.html());
        results.push({
          success: true,
          filePath,
          modificationType: 'fix_heading_hierarchy',
          description: `Fixed heading hierarchy: ${changes.length} heading(s) adjusted`,
          after: changes.join(', '),
        });
      }
    }

    if (results.length === 0) {
      results.push({
        success: true,
        filePath: 'all',
        modificationType: 'fix_heading_hierarchy',
        description: 'Heading hierarchy is correct',
      });
    }

    return results;
  }

  This handles:
  - Case 1: Document starts with h2+ → shift all headings up (h2→h1, h3→h2)
  - Case 2: Document starts with h1 but skips levels (h1→h3) → normalize to h1→h2
  - Also escapes attribute values to prevent malformed HTML