 Step 3: Update Auto-Remediation to Only Process Auto Tasks (Backend)

  // src/services/auto-remediation.service.ts

  import { getAutoFixableTasks } from './remediation-plan.service';
  import { isAutoFixable } from '../constants/fix-classification';

  interface RemediationResult {
    taskId: string;
    issueCode: string;
    status: 'fixed' | 'failed' | 'skipped';
    message?: string;
    error?: string;
  }

  interface AutoRemediationSummary {
    attempted: number;
    fixed: number;
    failed: number;
    skipped: number;
    quickFixPending: number;  // NEW: Tasks needing Quick Fix
    manualPending: number;    // NEW: Tasks needing manual fix
    results: RemediationResult[];
  }

  export async function runAutoRemediation(
    jobId: string,
    plan: RemediationPlan
  ): Promise<AutoRemediationSummary> {
    const autoTasks = getAutoFixableTasks(plan);
    const quickFixTasks = plan.tasks.filter(t => t.fixType === 'quickfix');
    const manualTasks = plan.tasks.filter(t => t.fixType === 'manual');

    console.log(`Auto-remediation starting:`);
    console.log(`  - ${autoTasks.length} auto-fixable tasks`);
    console.log(`  - ${quickFixTasks.length} quick-fix tasks (will be skipped)`);
    console.log(`  - ${manualTasks.length} manual tasks (will be skipped)`);

    const results: RemediationResult[] = [];

    // Process ONLY auto-fixable tasks
    for (const task of autoTasks) {
      try {
        // Double-check classification
        if (!isAutoFixable(task.issueCode)) {
          console.warn(`Task ${task.id} (${task.issueCode}) is not auto-fixable, skipping`);
          results.push({
            taskId: task.id,
            issueCode: task.issueCode,
            status: 'skipped',
            message: 'Requires user input via Quick Fix',
          });
          continue;
        }

        console.log(`Fixing: ${task.issueCode} at ${task.location}`);
        await applyAutoFix(jobId, task);

        results.push({
          taskId: task.id,
          issueCode: task.issueCode,
          status: 'fixed',
          message: 'Auto-fixed successfully',
        });
      } catch (error) {
        console.error(`Failed to fix ${task.issueCode}:`, error);
        results.push({
          taskId: task.id,
          issueCode: task.issueCode,
          status: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    }

    // Add skipped entries for quick-fix and manual tasks
    for (const task of quickFixTasks) {
      results.push({
        taskId: task.id,
        issueCode: task.issueCode,
        status: 'skipped',
        message: 'Requires Quick Fix Panel - user input needed',
      });
    }

    for (const task of manualTasks) {
      results.push({
        taskId: task.id,
        issueCode: task.issueCode,
        status: 'skipped',
        message: 'Requires manual code editing',
      });
    }

    const summary: AutoRemediationSummary = {
      attempted: autoTasks.length,
      fixed: results.filter(r => r.status === 'fixed').length,
      failed: results.filter(r => r.status === 'failed').length,
      skipped: results.filter(r => r.status === 'skipped').length,
      quickFixPending: quickFixTasks.length,
      manualPending: manualTasks.length,
      results,
    };

    console.log(`Auto-remediation complete:`, summary);

    return summary;
  }

  async function applyAutoFix(jobId: string, task: RemediationTask): Promise<void> {
    // Your existing auto-fix logic here
    // Only for truly auto-fixable issues
  }
