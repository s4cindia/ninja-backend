## Context
Setting up BullMQ for background job processing. Jobs will handle PDF/EPUB accessibility validation, VPAT generation, and other async tasks.

## Current State
- Backend API running
- Redis/KeyValue storage available in Replit
- Job model exists in Prisma schema

## Objective
Configure BullMQ with Redis connection and create the job queue infrastructure.

## Technical Requirements

**Install BullMQ:**
```bash
npm install bullmq ioredis
npm install -D @types/ioredis
```

**Create `src/config/redis.config.ts`:**
```typescript
import { RedisOptions } from 'ioredis';

export const redisConfig: RedisOptions = {
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379', 10),
  password: process.env.REDIS_PASSWORD || undefined,
  maxRetriesPerRequest: null, // Required for BullMQ
  enableReadyCheck: false,
};

// For Replit's KeyValue store, use the KV URL if available
export const getRedisUrl = (): string => {
  if (process.env.KV_URL) {
    return process.env.KV_URL;
  }
  if (process.env.REDIS_URL) {
    return process.env.REDIS_URL;
  }
  return `redis://${redisConfig.host}:${redisConfig.port}`;
};
```

**Create `src/lib/redis.ts`:**
```typescript
import Redis from 'ioredis';
import { getRedisUrl } from '../config/redis.config.js';

let redisClient: Redis | null = null;

export function getRedisClient(): Redis {
  if (!redisClient) {
    const redisUrl = getRedisUrl();
    
    redisClient = new Redis(redisUrl, {
      maxRetriesPerRequest: null,
      enableReadyCheck: false,
      retryStrategy: (times) => {
        if (times > 3) {
          console.error('Redis connection failed after 3 retries');
          return null;
        }
        return Math.min(times * 200, 1000);
      },
    });

    redisClient.on('connect', () => {
      console.log('ðŸ“¦ Redis connected');
    });

    redisClient.on('error', (err) => {
      console.error('Redis error:', err.message);
    });
  }

  return redisClient;
}

export async function closeRedisConnection(): Promise<void> {
  if (redisClient) {
    await redisClient.quit();
    redisClient = null;
  }
}
```

**Create `src/queues/index.ts`:**
```typescript
import { Queue, QueueEvents } from 'bullmq';
import { getRedisClient } from '../lib/redis.js';

// Queue names
export const QUEUE_NAMES = {
  ACCESSIBILITY: 'accessibility-validation',
  VPAT: 'vpat-generation',
  FILE_PROCESSING: 'file-processing',
} as const;

export type QueueName = typeof QUEUE_NAMES[keyof typeof QUEUE_NAMES];

// Job types
export const JOB_TYPES = {
  PDF_ACCESSIBILITY: 'PDF_ACCESSIBILITY',
  EPUB_ACCESSIBILITY: 'EPUB_ACCESSIBILITY',
  VPAT_GENERATION: 'VPAT_GENERATION',
  ALT_TEXT_GENERATION: 'ALT_TEXT_GENERATION',
  METADATA_EXTRACTION: 'METADATA_EXTRACTION',
  BATCH_VALIDATION: 'BATCH_VALIDATION',
} as const;

export type JobType = typeof JOB_TYPES[keyof typeof JOB_TYPES];

// Job data interface
export interface JobData {
  type: JobType;
  tenantId: string;
  userId: string;
  fileId?: string;
  productId?: string;
  options?: Record<string, unknown>;
}

// Job result interface
export interface JobResult {
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
}

// Create queues
const connection = getRedisClient();

export const accessibilityQueue = new Queue<JobData, JobResult>(
  QUEUE_NAMES.ACCESSIBILITY,
  {
    connection,
    defaultJobOptions: {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 1000,
      },
      removeOnComplete: {
        count: 100,
        age: 24 * 60 * 60, // 24 hours
      },
      removeOnFail: {
        count: 500,
        age: 7 * 24 * 60 * 60, // 7 days
      },
    },
  }
);

export const vpatQueue = new Queue<JobData, JobResult>(
  QUEUE_NAMES.VPAT,
  {
    connection,
    defaultJobOptions: {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 1000,
      },
      removeOnComplete: {
        count: 100,
        age: 24 * 60 * 60,
      },
      removeOnFail: {
        count: 500,
        age: 7 * 24 * 60 * 60,
      },
    },
  }
);

export const fileProcessingQueue = new Queue<JobData, JobResult>(
  QUEUE_NAMES.FILE_PROCESSING,
  {
    connection,
    defaultJobOptions: {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 1000,
      },
      removeOnComplete: {
        count: 100,
        age: 24 * 60 * 60,
      },
      removeOnFail: {
        count: 500,
        age: 7 * 24 * 60 * 60,
      },
    },
  }
);

// Queue events for monitoring
export const accessibilityQueueEvents = new QueueEvents(QUEUE_NAMES.ACCESSIBILITY, {
  connection,
});

export const vpatQueueEvents = new QueueEvents(QUEUE_NAMES.VPAT, {
  connection,
});

// Export all queues
export const queues = {
  [QUEUE_NAMES.ACCESSIBILITY]: accessibilityQueue,
  [QUEUE_NAMES.VPAT]: vpatQueue,
  [QUEUE_NAMES.FILE_PROCESSING]: fileProcessingQueue,
};

// Get queue by name
export function getQueue(name: QueueName): Queue<JobData, JobResult> {
  return queues[name];
}

// Graceful shutdown
export async function closeQueues(): Promise<void> {
  await Promise.all([
    accessibilityQueue.close(),
    vpatQueue.close(),
    fileProcessingQueue.close(),
    accessibilityQueueEvents.close(),
    vpatQueueEvents.close(),
  ]);
}
```

**Create `src/services/queue.service.ts`:**
```typescript
import { Job } from 'bullmq';
import { prisma } from '../lib/prisma.js';
import { 
  accessibilityQueue, 
  vpatQueue, 
  fileProcessingQueue,
  JobData, 
  JobResult,
  JOB_TYPES,
  JobType,
} from '../queues/index.js';
import { AppError } from '../utils/app-error.js';
import { ErrorCodes } from '../utils/error-codes.js';

export interface CreateJobInput {
  type: JobType;
  tenantId: string;
  userId: string;
  fileId?: string;
  productId?: string;
  priority?: number;
  options?: Record<string, unknown>;
}

export class QueueService {
  async createJob(input: CreateJobInput): Promise<string> {
    const { type, tenantId, userId, fileId, productId, priority = 0, options } = input;

    // Create job record in database
    const dbJob = await prisma.job.create({
      data: {
        type,
        status: 'QUEUED',
        priority,
        input: options || {},
        tenantId,
        userId,
        productId,
      },
    });

    // Prepare job data
    const jobData: JobData = {
      type,
      tenantId,
      userId,
      fileId,
      productId,
      options,
    };

    // Add to appropriate queue
    let queueJob: Job<JobData, JobResult>;

    switch (type) {
      case JOB_TYPES.PDF_ACCESSIBILITY:
      case JOB_TYPES.EPUB_ACCESSIBILITY:
      case JOB_TYPES.BATCH_VALIDATION:
        queueJob = await accessibilityQueue.add(type, jobData, {
          jobId: dbJob.id,
          priority,
        });
        break;

      case JOB_TYPES.VPAT_GENERATION:
        queueJob = await vpatQueue.add(type, jobData, {
          jobId: dbJob.id,
          priority,
        });
        break;

      case JOB_TYPES.ALT_TEXT_GENERATION:
      case JOB_TYPES.METADATA_EXTRACTION:
        queueJob = await fileProcessingQueue.add(type, jobData, {
          jobId: dbJob.id,
          priority,
        });
        break;

      default:
        throw AppError.badRequest(`Unknown job type: ${type}`);
    }

    console.log(`ðŸ“‹ Job ${dbJob.id} added to queue: ${type}`);
    return dbJob.id;
  }

  async getJobStatus(jobId: string, tenantId: string) {
    const job = await prisma.job.findFirst({
      where: { id: jobId, tenantId },
      select: {
        id: true,
        type: true,
        status: true,
        progress: true,
        output: true,
        error: true,
        createdAt: true,
        startedAt: true,
        completedAt: true,
      },
    });

    if (!job) {
      throw AppError.notFound('Job not found', ErrorCodes.JOB_NOT_FOUND);
    }

    return job;
  }

  async cancelJob(jobId: string, tenantId: string): Promise<void> {
    const job = await prisma.job.findFirst({
      where: { id: jobId, tenantId },
    });

    if (!job) {
      throw AppError.notFound('Job not found', ErrorCodes.JOB_NOT_FOUND);
    }

    if (job.status === 'COMPLETED' || job.status === 'FAILED') {
      throw AppError.badRequest('Cannot cancel completed or failed job', ErrorCodes.JOB_CANNOT_CANCEL);
    }

    // Update database
    await prisma.job.update({
      where: { id: jobId },
      data: { status: 'CANCELLED' },
    });

    // Try to remove from queue if still queued
    try {
      const queueJob = await accessibilityQueue.getJob(jobId);
      if (queueJob) {
        await queueJob.remove();
      }
    } catch (err) {
      console.error('Failed to remove job from queue:', err);
    }
  }

  async updateJobProgress(jobId: string, progress: number): Promise<void> {
    await prisma.job.update({
      where: { id: jobId },
      data: { progress },
    });
  }

  async updateJobStatus(
    jobId: string, 
    status: 'PROCESSING' | 'COMPLETED' | 'FAILED',
    data?: { output?: Record<string, unknown>; error?: string }
  ): Promise<void> {
    const updateData: any = { status };

    if (status === 'PROCESSING') {
      updateData.startedAt = new Date();
    } else if (status === 'COMPLETED' || status === 'FAILED') {
      updateData.completedAt = new Date();
    }

    if (data?.output) {
      updateData.output = data.output;
    }

    if (data?.error) {
      updateData.error = data.error;
    }

    await prisma.job.update({
      where: { id: jobId },
      data: updateData,
    });
  }
}

export const queueService = new QueueService();
```

**Update `src/index.ts` to handle graceful shutdown:**

Add at the end of the file, before `export default app;`:
```typescript
import { closeQueues } from './queues/index.js';
import { closeRedisConnection } from './lib/redis.js';

// Graceful shutdown
const gracefulShutdown = async () => {
  console.log('Shutting down gracefully...');
  
  server.close(async () => {
    console.log('HTTP server closed');
    
    await closeQueues();
    console.log('Queues closed');
    
    await closeRedisConnection();
    console.log('Redis connection closed');
    
    process.exit(0);
  });
};

process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);
```

## Tasks
1. Install bullmq and ioredis packages
2. Create src/config/redis.config.ts
3. Create src/lib/redis.ts with connection management
4. Create src/queues/index.ts with queue definitions
5. Create src/services/queue.service.ts
6. Update src/index.ts for graceful shutdown
7. Verify server starts without errors

## Acceptance Criteria
- [ ] BullMQ and ioredis installed
- [ ] Redis connection configured for Replit's KeyValue store
- [ ] Three queues created (accessibility, vpat, file-processing)
- [ ] QueueService can create and manage jobs
- [ ] Graceful shutdown closes queues and Redis connection
- [ ] Server starts without errors